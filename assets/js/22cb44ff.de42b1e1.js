"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[5532],{88820:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var n=s(74848),r=s(28453);const o={},c="Computed Properties",d={id:"frontend/vue3/core/essentials/computed-properties",title:"Computed Properties",description:"Basic Example",source:"@site/docs/00200-frontend/vue3/010-core/011-essentials/040-computed-properties.md",sourceDirName:"00200-frontend/vue3/010-core/011-essentials",slug:"/frontend/vue3/core/essentials/computed-properties",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/computed-properties",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:40,frontMatter:{},sidebar:"docSidebar",previous:{title:"Reactivity Fundamentals",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/reactivity-fundamentals"},next:{title:"Class and Style Bindings",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/class-and-style-bindings"}},i={},a=[{value:"Basic Example",id:"basic-example",level:2},{value:"Computed Caching vs. Methods",id:"computed-caching-vs-methods",level:2},{value:"Best Practices",id:"best-practices",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"computed-properties",children:"Computed Properties"}),"\n",(0,n.jsx)(t.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,n.jsxs)(t.p,{children:["That's why for ",(0,n.jsx)(t.strong,{children:"complex logic that includes reactive data"}),", it is recommended to use a computed property"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"computed()"})," function expects to be passed a ",(0,n.jsx)(t.code,{children:"getter function"}),", and the returned value is a ",(0,n.jsx)(t.strong,{children:"computed ref"}),". Similar to normal refs, you can access the computed result as ",(0,n.jsx)(t.code,{children:"publishedBooksMessage.value"}),". Computed refs are also ",(0,n.jsx)(t.strong,{children:"auto-unwrapped in templates"})," so you can reference them without .value in template expressions"]}),"\n",(0,n.jsx)(t.p,{children:"A computed property automatically tracks its reactive dependencies"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"<script setup>\r\nimport { reactive, computed } from 'vue'\r\n\r\nconst author = reactive({\r\n  name: 'John Doe',\r\n  books: [\r\n    'Vue 2 - Advanced Guide',\r\n    'Vue 3 - Basic Guide',\r\n    'Vue 4 - The Mystery'\r\n  ]\r\n})\r\n\r\n// a computed ref\r\nconst publishedBooksMessage = computed(() => {\r\n  return author.books.length > 0 ? 'Yes' : 'No'\r\n})\r\n<\/script>\r\n\r\n<template>\r\n  <p>Has published books:</p>\r\n  <span>{{ publishedBooksMessage }}</span>\r\n</template>\n"})}),"\n",(0,n.jsx)(t.h2,{id:"computed-caching-vs-methods",children:"Computed Caching vs. Methods"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"computed properties are cached based on their reactive dependencies"})}),"\n",(0,n.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Getters should be side-effect free"}),"\n",(0,n.jsx)(t.li,{children:"Avoid mutating computed value"}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>d});var n=s(96540);const r={},o=n.createContext(r);function c(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);