"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[79421],{7563:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var t=o(74848),r=o(28453);const l={},s=void 0,i={id:"programming-languages/python/pep/2017-0544-Protocols-Structural-subtyping",title:"2017-0544-Protocols-Structural-subtyping",description:"https://peps.python.org/pep-0544/",source:"@site/docs/00400-programming-languages/python/pep/2017-0544-Protocols-Structural-subtyping.md",sourceDirName:"00400-programming-languages/python/pep",slug:"/programming-languages/python/pep/2017-0544-Protocols-Structural-subtyping",permalink:"/dddtdd-docs/programming-languages/python/pep/2017-0544-Protocols-Structural-subtyping",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1726186426e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"2016-0526-Syntax-for-Variable-Annotations",permalink:"/dddtdd-docs/programming-languages/python/pep/2016-0526-Syntax-for-Variable-Annotations"},next:{title:"2017-0561-Distributing-and-Packaging-Type-Information",permalink:"/dddtdd-docs/programming-languages/python/pep/2017-0561-Distributing-and-Packaging-Type-Information"}},a={},c=[{value:"Rationale and Goals",id:"rationale-and-goals",level:2},{value:"Specification",id:"specification",level:2},{value:"Terminology",id:"terminology",level:3},{value:"Defining a protocol",id:"defining-a-protocol",level:3},{value:"Protocol members",id:"protocol-members",level:3},{value:"Explicitly declaring implementation",id:"explicitly-declaring-implementation",level:3},{value:"Merging and extending protocols",id:"merging-and-extending-protocols",level:3},{value:"Generic protocols",id:"generic-protocols",level:3},{value:"Recursive protocols",id:"recursive-protocols",level:3},{value:"Callback protocols",id:"callback-protocols",level:3},{value:"Runtime Implementation of Protocol Classes",id:"runtime-implementation-of-protocol-classes",level:2},{value:"Changes in the typing module",id:"changes-in-the-typing-module",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://peps.python.org/pep-0544/",children:"https://peps.python.org/pep-0544/"})}),"\n",(0,t.jsx)(n.h2,{id:"rationale-and-goals",children:"Rationale and Goals"}),"\n",(0,t.jsxs)(n.p,{children:["Currently, PEP 484 and the ",(0,t.jsx)(n.code,{children:"typing"})," module define abstract base classes for several common Python protocols such as ",(0,t.jsx)(n.code,{children:"Iterable"})," and ",(0,t.jsx)(n.code,{children:"Sized"}),". The ",(0,t.jsx)(n.strong,{children:"problem"})," with them is that a class ",(0,t.jsx)(n.strong,{children:"has to be explicitly marked"})," to support them"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Sized, Iterable, Iterator\r\n\r\nclass Bucket(Sized, Iterable[int]):\r\n    ...\r\n    def __len__(self) -> int: ...\r\n    def __iter__(self) -> Iterator[int]: ...\n"})}),"\n",(0,t.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,t.jsx)(n.h3,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(n.p,{children:["We propose to use the term ",(0,t.jsx)(n.code,{children:"protocols"})," for types supporting structural subtyping. The reason is that the term ",(0,t.jsx)(n.code,{children:"iterator protocol"}),", for example, is widely understood in the community"]}),"\n",(0,t.jsxs)(n.p,{children:["If a class includes a protocol in its MRO, the class is called an ",(0,t.jsx)(n.strong,{children:"explicit subclass of the protocol"}),". If a class is a structural subtype of a protocol, it is said to implement the protocol and to be ",(0,t.jsx)(n.strong,{children:"compatible with a protocol"}),". If a class is compatible with a protocol but the protocol is not included in the MRO, the class is an ",(0,t.jsx)(n.strong,{children:"implicit subtype of the protocol"})]}),"\n",(0,t.jsxs)(n.p,{children:["The attributes (variables and methods) of a protocol that are mandatory for other class in order to be considered a structural subtype are called ",(0,t.jsx)(n.strong,{children:"protocol members"})]}),"\n",(0,t.jsx)(n.h3,{id:"defining-a-protocol",children:"Defining a protocol"}),"\n",(0,t.jsxs)(n.p,{children:["Protocols are defined by including a special new class ",(0,t.jsx)(n.code,{children:"typing.Protocol"})," (an instance of ",(0,t.jsx)(n.code,{children:"abc.ABCMeta"}),") in the base classes list, typically at the end of the list"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Protocol\r\n\r\nclass SupportsClose(Protocol):\r\n    def close(self) -> None:\r\n        ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"protocol-members",children:"Protocol members"}),"\n",(0,t.jsxs)(n.p,{children:["All methods defined in the protocol class body are protocol members, both normal and decorated with ",(0,t.jsx)(n.code,{children:"@abstractmethod"}),". If any parameters of a protocol method are not annotated, then their types are assumed to be ",(0,t.jsx)(n.code,{children:"Any"})," (see PEP 484). Bodies of protocol methods are type checked. An abstract method that should not be called via super() ought to raise NotImplementedError"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Protocol\r\nfrom abc import abstractmethod\r\n\r\nclass Example(Protocol):\r\n    def first(self) -> int:     # This is a protocol member\r\n        return 42\r\n\r\n    @abstractmethod\r\n    def second(self) -> int:    # Method without a default implementation\r\n        raise NotImplementedError\n"})}),"\n",(0,t.jsx)(n.p,{children:"To define a protocol variable, one can use PEP 526 variable annotations in the class body"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Protocol, List\r\n\r\nclass Template(Protocol):\r\n    name: str        # This is a protocol member\r\n    value: int = 0   # This one too (with default)\r\n\r\n    def method(self) -> None:\r\n        self.temp: List[int] = [] # Error in type checker\r\n\r\nclass Concrete:\r\n    def __init__(self, name: str, value: int) -> None:\r\n        self.name = name\r\n        self.value = value\r\n\r\n    def method(self) -> None:\r\n        return\r\n\r\nvar: Template = Concrete('value', 42)  # OK\n"})}),"\n",(0,t.jsx)(n.h3,{id:"explicitly-declaring-implementation",children:"Explicitly declaring implementation"}),"\n",(0,t.jsx)(n.p,{children:"To explicitly declare that a certain class implements a given protocol, it can be used as a regular base class. In this case a class could use default implementations of protocol members"}),"\n",(0,t.jsx)(n.h3,{id:"merging-and-extending-protocols",children:"Merging and extending protocols"}),"\n",(0,t.jsxs)(n.p,{children:["Subclassing a protocol class would ",(0,t.jsx)(n.strong,{children:"not turn"})," the subclass into a protocol unless it also has ",(0,t.jsx)(n.code,{children:"typing.Protocol"})," as an explicit base class"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Sized\r\n\r\nclass SupportsClose(Protocol):\r\n    def close(self) -> None:\r\n        ...\r\n\r\nclass SizedAndClosable(Sized, SupportsClose, Protocol):\r\n    pass\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"Protocol"})," is included in the base class list, all the other base classes must be protocols"]}),"\n",(0,t.jsx)(n.h3,{id:"generic-protocols",children:"Generic protocols"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Iterable(Protocol[T]):\r\n    @abstractmethod\r\n    def __iter__(self) -> Iterator[T]:\r\n        ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Protocol[T, S, ...]"})," is allowed as a shorthand for ",(0,t.jsx)(n.code,{children:"Protocol, Generic[T, S, ...]"})]}),"\n",(0,t.jsx)(n.h3,{id:"recursive-protocols",children:"Recursive protocols"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Traversable(Protocol):\r\n    def leaves(self) -> Iterable['Traversable']:\r\n        ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"callback-protocols",children:"Callback protocols"}),"\n",(0,t.jsxs)(n.p,{children:["Protocols can be used to define flexible callback types that are hard (or even impossible) to express using the ",(0,t.jsx)(n.code,{children:"Callable[...]"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Optional, List, Protocol\r\n\r\nclass Combiner(Protocol):\r\n    def __call__(self, *vals: bytes,\r\n                 maxlen: Optional[int] = None) -> List[bytes]: ...\r\n\r\ndef good_cb(*vals: bytes, maxlen: Optional[int] = None) -> List[bytes]:\r\n    ...\r\ndef bad_cb(*vals: bytes, maxitems: Optional[int]) -> List[bytes]:\r\n    ...\r\n\r\ncomb: Combiner = good_cb  # OK\r\ncomb = bad_cb  # Error! Argument 2 has incompatible type because of\r\n               # different name and kind in the callback\n"})}),"\n",(0,t.jsx)(n.h2,{id:"runtime-implementation-of-protocol-classes",children:"Runtime Implementation of Protocol Classes"}),"\n",(0,t.jsx)(n.h3,{id:"changes-in-the-typing-module",children:"Changes in the typing module"}),"\n",(0,t.jsx)(n.p,{children:"The following classes in typing module will be protocols:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Callable"}),"\n",(0,t.jsx)(n.li,{children:"Awaitable"}),"\n",(0,t.jsx)(n.li,{children:"Iterable, Iterator"}),"\n",(0,t.jsx)(n.li,{children:"AsyncIterable, AsyncIterator"}),"\n",(0,t.jsx)(n.li,{children:"Hashable"}),"\n",(0,t.jsx)(n.li,{children:"Sized"}),"\n",(0,t.jsx)(n.li,{children:"Container"}),"\n",(0,t.jsx)(n.li,{children:"Collection"}),"\n",(0,t.jsx)(n.li,{children:"Reversible"}),"\n",(0,t.jsx)(n.li,{children:"ContextManager, AsyncContextManager"}),"\n",(0,t.jsx)(n.li,{children:"SupportsAbs (and other Supports* classes)"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var t=o(96540);const r={},l=t.createContext(r);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);