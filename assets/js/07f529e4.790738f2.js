"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[551],{65275:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=s(74848),i=s(28453);const r={},a=void 0,l={id:"programming-languages/python/pep/2014-0484-Type-Hints",title:"2014-0484-Type-Hints",description:"https://peps.python.org/pep-0484",source:"@site/docs/00400-programming-languages/python/pep/2014-0484-Type-Hints.md",sourceDirName:"00400-programming-languages/python/pep",slug:"/programming-languages/python/pep/2014-0484-Type-Hints",permalink:"/dddtdd-docs/programming-languages/python/pep/2014-0484-Type-Hints",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1726186426e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"2014-0483-The-Theory-of-Type-Hints",permalink:"/dddtdd-docs/programming-languages/python/pep/2014-0483-The-Theory-of-Type-Hints"},next:{title:"2015-0492-Coroutines-with-async-and-await-syntax",permalink:"/dddtdd-docs/programming-languages/python/pep/2015-0492-Coroutines-with-async-and-await-syntax"}},o={},c=[{value:"Type Definition Syntax",id:"type-definition-syntax",level:2},{value:"Acceptable type hints",id:"acceptable-type-hints",level:3},{value:"Using None",id:"using-none",level:3},{value:"Type aliases",id:"type-aliases",level:3},{value:"Callable",id:"callable",level:3},{value:"Generics",id:"generics",level:3},{value:"User-defined generic types",id:"user-defined-generic-types",level:3},{value:"Scoping rules for type variables",id:"scoping-rules-for-type-variables",level:3},{value:"Instantiating generic classes and type erasure",id:"instantiating-generic-classes-and-type-erasure",level:3},{value:"Abstract generic types",id:"abstract-generic-types",level:3},{value:"Type variables with an upper bound",id:"type-variables-with-an-upper-bound",level:3},{value:"Covariance and contravariance",id:"covariance-and-contravariance",level:3},{value:"Union types",id:"union-types",level:3},{value:"Support for singleton types in unions",id:"support-for-singleton-types-in-unions",level:3},{value:"The NoReturn type",id:"the-noreturn-type",level:3},{value:"The type of class objects",id:"the-type-of-class-objects",level:3},{value:"Annotating instance and class methods",id:"annotating-instance-and-class-methods",level:3},{value:"Annotating generator functions and coroutines",id:"annotating-generator-functions-and-coroutines",level:3},{value:"Compatibility with other uses of function annotations",id:"compatibility-with-other-uses-of-function-annotations",level:2},{value:"Type comments",id:"type-comments",level:2},{value:"Casts",id:"casts",level:2},{value:"NewType helper function",id:"newtype-helper-function",level:2},{value:"Stub Files",id:"stub-files",level:2},{value:"Function/method overloading",id:"functionmethod-overloading",level:3},{value:"The typing Module",id:"the-typing-module",level:2},{value:"Fundamental building blocks",id:"fundamental-building-blocks",level:3},{value:"Generic variants of builtin collections",id:"generic-variants-of-builtin-collections",level:3},{value:"Generic variants of container ABCs (and a few non-containers)",id:"generic-variants-of-container-abcs-and-a-few-non-containers",level:3},{value:"Convenience definitions",id:"convenience-definitions",level:3},{value:"I/O related types",id:"io-related-types",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://peps.python.org/pep-0484",children:"https://peps.python.org/pep-0484"})}),"\n",(0,t.jsxs)(n.p,{children:["This PEP introduces a provisional module to provide these ",(0,t.jsx)(n.strong,{children:"standard definitions and tools"}),", along with some conventions for situations where annotations are not available"]}),"\n",(0,t.jsxs)(n.p,{children:["The proposal is strongly inspired by ",(0,t.jsx)(n.strong,{children:"mypy"})]}),"\n",(0,t.jsx)(n.h2,{id:"type-definition-syntax",children:"Type Definition Syntax"}),"\n",(0,t.jsx)(n.h3,{id:"acceptable-type-hints",children:"Acceptable type hints"}),"\n",(0,t.jsxs)(n.p,{children:["Type hints may be ",(0,t.jsx)(n.strong,{children:"built-in classes"})," (including those defined in standard library or third-party extension modules), ",(0,t.jsx)(n.strong,{children:"abstract base classes"}),", types available in the ",(0,t.jsx)(n.strong,{children:"types module"}),", and ",(0,t.jsx)(n.strong,{children:"user-defined classes"})," (including those defined in the standard library or third-party modules)"]}),"\n",(0,t.jsxs)(n.p,{children:["While annotations are normally the best format for type hints, there are times when it is more appropriate to represent them ",(0,t.jsx)(n.strong,{children:"by a special comment"}),", or in a separately distributed ",(0,t.jsx)(n.strong,{children:"stub file"})]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the above, the following special constructs defined below may be used: ",(0,t.jsx)(n.code,{children:"None"}),", ",(0,t.jsx)(n.code,{children:"Any"}),", ",(0,t.jsx)(n.code,{children:"Union"}),", ",(0,t.jsx)(n.code,{children:"Tuple"}),", ",(0,t.jsx)(n.code,{children:"Callable"}),", all ",(0,t.jsx)(n.code,{children:"ABCs"})," and stand-ins for concrete classes exported from ",(0,t.jsx)(n.code,{children:"typing"})," (e.g. ",(0,t.jsx)(n.code,{children:"Sequence"})," and ",(0,t.jsx)(n.code,{children:"Dict"}),"), ",(0,t.jsx)(n.strong,{children:"type variables"}),", and ",(0,t.jsx)(n.strong,{children:"type aliases"})]}),"\n",(0,t.jsx)(n.h3,{id:"using-none",children:"Using None"}),"\n",(0,t.jsxs)(n.p,{children:["When used in a type hint, the expression None is considered equivalent to ",(0,t.jsx)(n.code,{children:"type(None)"})]}),"\n",(0,t.jsx)(n.h3,{id:"type-aliases",children:"Type aliases"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"Url = str\n\ndef retry(url: Url, retry_count: int) -> None: ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import TypeVar, Iterable, Tuple\n\nT = TypeVar('T', int, float, complex)\nVector = Iterable[Tuple[T, T]]\n\ndef inproduct(v: Vector[T]) -> T:\n    return sum(x*y for x, y in v)\ndef dilate(v: Vector[T], scale: T) -> Vector[T]:\n    return ((x * scale, y * scale) for x, y in v)\nvec = []  # type: Vector[float]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"callable",children:"Callable"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Callable\n\ndef feeder(get_next_item: Callable[[], str]) -> None:\n    # Body\n\ndef async_query(on_success: Callable[[int], None],\n                on_error: Callable[[int, Exception], None]) -> None:\n    # Body\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It is possible to declare the return type of a callable without specifying the call signature by substituting a literal ",(0,t.jsx)(n.strong,{children:"ellipsis"})," (three dots) for the list of arguments"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def partial(func: Callable[..., str], *args) -> Callable[..., str]:\n    # Body\n"})}),"\n",(0,t.jsx)(n.h3,{id:"generics",children:"Generics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Mapping, Set\n\ndef notify_by_email(employees: Set[Employee], overrides: Mapping[str, str]) -> None: ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Sequence, TypeVar\n\nT = TypeVar('T')      # Declare type variable\n\ndef first(l: Sequence[T]) -> T:   # Generic function\n    return l[0]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"TypeVar()"})," expression must always directly be assigned to a variable (it should not be used as part of a larger expression). The argument to ",(0,t.jsx)(n.code,{children:"TypeVar()"})," must be a string equal to the variable name to which it is assigned"]}),"\n",(0,t.jsx)(n.h3,{id:"user-defined-generic-types",children:"User-defined generic types"}),"\n",(0,t.jsxs)(n.p,{children:["You can include a ",(0,t.jsx)(n.code,{children:"Generic"})," base class to define a user-defined class as generic"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import TypeVar, Generic\nfrom logging import Logger\n\nT = TypeVar('T')\n\nclass LoggedVar(Generic[T]):\n    def __init__(self, value: T, name: str, logger: Logger) -> None:\n        self.name = name\n        self.logger = logger\n        self.value = value\n\n    def set(self, new: T) -> None:\n        self.log('Set ' + repr(self.value))\n        self.value = new\n\n    def get(self) -> T:\n        self.log('Get ' + repr(self.value))\n        return self.value\n\n    def log(self, message: str) -> None:\n        self.logger.info('{}: {}'.format(self.name, message))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Generic"})," base class uses a metaclass that defines ",(0,t.jsx)(n.code,{children:"__getitem__"})," so that ",(0,t.jsx)(n.code,{children:"LoggedVar[t]"})," is valid as a type"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Iterable\n\ndef zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:\n    for var in vars:\n        var.set(0)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Subclassing a generic class without specifying type parameters assumes ",(0,t.jsx)(n.code,{children:"Any"})," for each position. In the following example, MyIterable is not generic but implicitly inherits from ",(0,t.jsx)(n.code,{children:"Iterable[Any]"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Iterable\n\nclass MyIterable(Iterable):  # Same as Iterable[Any]\n    ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scoping-rules-for-type-variables",children:"Scoping rules for type variables"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A type variable used in a method that does not match any of the variables that parameterize the class makes this method a generic function in that variable"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"T = TypeVar('T')\nS = TypeVar('S')\nclass Foo(Generic[T]):\n    def method(self, x: T, y: S) -> S:\n        ...\n\nx = Foo()               # type: Foo[int]\ny = x.method(0, \"abc\")  # inferred type of y is str\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Unbound type variables should not appear in the bodies of generic functions, or in the class bodies apart from method definitions"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"T = TypeVar('T')\nS = TypeVar('S')\n\ndef a_fun(x: T) -> None:\n    # this is OK\n    y = []  # type: List[T]\n    # but below is an error!\n    y = []  # type: List[S]\n\nclass Bar(Generic[T]):\n    # this is also an error\n    an_attr = []  # type: List[S]\n\n    def do_something(x: S) -> S:  # this is OK though\n        ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"instantiating-generic-classes-and-type-erasure",children:"Instantiating generic classes and type erasure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Node(Generic[T]):\n    x = None  # type: T # Instance attribute (see below)\n    def __init__(self, label: T = None) -> None:\n        ...\n\nx = Node('')  # Inferred type is Node[str]\ny = Node(0)   # Inferred type is Node[int]\nz = Node()    # Inferred type is Node[Any]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To create Node instances you call ",(0,t.jsx)(n.code,{children:"Node()"})," just as for a regular class. ",(0,t.jsx)(n.strong,{children:"At runtime"})," the type (class) of the instance will be ",(0,t.jsx)(n.code,{children:"Node"}),". But what type does it have to the type checker? The answer depends on how much information is available in the call. If the constructor (",(0,t.jsx)(n.code,{children:"__init__"})," or ",(0,t.jsx)(n.code,{children:"__new__"}),") uses ",(0,t.jsx)(n.code,{children:"T"})," in its signature, and a corresponding argument value is passed, the ",(0,t.jsx)(n.strong,{children:"type of the corresponding argument(s)"})," is substituted. Otherwise, ",(0,t.jsx)(n.code,{children:"Any"})," is assumed"]}),"\n",(0,t.jsxs)(n.p,{children:["In case the inferred type uses ",(0,t.jsx)(n.code,{children:"[Any]"})," but the intended type is more specific, you can use a ",(0,t.jsx)(n.strong,{children:"type comment"})," (see below) to force the type of the variable"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"a = Node()  # type: Node[int]\nb = Node()  # type: Node[str]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, you can instantiate a specific ",(0,t.jsx)(n.strong,{children:"concrete type"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"p = Node[int]()\nq = Node[str]()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Node[int]"})," and ",(0,t.jsx)(n.code,{children:"Node[str]"})," are distinguishable class objects, but the runtime class of the objects created by instantiating them doesn\u2019t record the distinction. This behavior is called ",(0,t.jsx)(n.strong,{children:"\u201ctype erasure\u201d"})]}),"\n",(0,t.jsxs)(n.p,{children:["It is not recommended to use the subscripted class (e.g. ",(0,t.jsx)(n.code,{children:"Node[int]"}),") directly in an expression \u2013 using a type alias (e.g. ",(0,t.jsx)(n.code,{children:"IntNode = Node[int]"}),") instead is preferred. (First, creating the subscripted class, e.g. ",(0,t.jsx)(n.code,{children:"Node[int]"}),", has a ",(0,t.jsx)(n.strong,{children:"runtime cost"}),". Second, using a type alias is more ",(0,t.jsx)(n.strong,{children:"readable"}),".)"]}),"\n",(0,t.jsx)(n.h3,{id:"abstract-generic-types",children:"Abstract generic types"}),"\n",(0,t.jsxs)(n.p,{children:["The metaclass used by ",(0,t.jsx)(n.code,{children:"Generic"})," is a subclass of ",(0,t.jsx)(n.code,{children:"abc.ABCMeta"}),". A generic class can be an ABC by including abstract methods or properties, and generic classes can also have ABCs as base classes without a ",(0,t.jsx)(n.strong,{children:"metaclass conflict"})]}),"\n",(0,t.jsx)(n.h3,{id:"type-variables-with-an-upper-bound",children:"Type variables with an upper bound"}),"\n",(0,t.jsxs)(n.p,{children:["A type variable may specify an upper bound using ",(0,t.jsx)(n.code,{children:"bound=<type>"})," (note: ",(0,t.jsx)(n.code,{children:"<type>"})," itself cannot be parameterized by type variables). This means that an actual type substituted (explicitly or implicitly) for the type variable ",(0,t.jsx)(n.strong,{children:"must be a subtype of the boundary type"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import TypeVar, Sized\n\nST = TypeVar('ST', bound=Sized)\n\ndef longer(x: ST, y: ST) -> ST:\n    if len(x) > len(y):\n        return x\n    else:\n        return y\n\nlonger([1], [1, 2])  # ok, return type List[int]\nlonger({1}, {1, 2})  # ok, return type Set[int]\nlonger([1], {1, 2})  # ok, return type Collection[int]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"covariance-and-contravariance",children:"Covariance and contravariance"}),"\n",(0,t.jsxs)(n.p,{children:["The read-only collection classes in typing are all declared ",(0,t.jsx)(n.strong,{children:"covariant"})," in their type variable (e.g. ",(0,t.jsx)(n.code,{children:"Mapping"})," and ",(0,t.jsx)(n.code,{children:"Sequence"}),"). The mutable collection classes (e.g. ",(0,t.jsx)(n.code,{children:"MutableMapping"})," and ",(0,t.jsx)(n.code,{children:"MutableSequence"}),") are declared ",(0,t.jsx)(n.strong,{children:"invariant"}),". The one example of a ",(0,t.jsx)(n.strong,{children:"contravariant"})," type is the ",(0,t.jsx)(n.code,{children:"Generator"})," type, which is contravariant in the ",(0,t.jsx)(n.code,{children:"send()"})," argument type"]}),"\n",(0,t.jsx)(n.p,{children:"Variance is only applicable to generic types; generic functions do not have this property"}),"\n",(0,t.jsx)(n.h3,{id:"union-types",children:"Union types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Union\n\ndef handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:\n    if isinstance(e, Employee):\n        e = [e]\n    ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def handle_employee(e: Union[Employee, None]) -> None: ...\n\nfrom typing import Optional\n\ndef handle_employee(e: Optional[Employee]) -> None: ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"support-for-singleton-types-in-unions",children:"Support for singleton types in unions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Reason(Enum):\n    timeout = 1\n    error = 2\n\ndef process(response: Union[str, Reason] = '') -> str:\n    if response is Reason.timeout:\n        return 'TIMEOUT'\n    elif response is Reason.error:\n        return 'ERROR'\n    else:\n        # response can be only str, all other possible values exhausted\n        return 'PROCESSED: ' + response\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-noreturn-type",children:"The NoReturn type"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"typing"})," module provides a special type ",(0,t.jsx)(n.code,{children:"NoReturn"})," to annotate functions that ",(0,t.jsx)(n.strong,{children:"never return normally"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import NoReturn\n\ndef stop() -> NoReturn:\n    raise RuntimeError('no way')\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-type-of-class-objects",children:"The type of class objects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"U = TypeVar('U', bound=User)\ndef new_user(user_class: Type[U]) -> U:\n    user = user_class()\n    ...\n\ndef new_non_team_user(user_class: Type[Union[BasicUser, ProUser]]):\n    user = new_user(user_class)\n    ...    \n"})}),"\n",(0,t.jsx)(n.h3,{id:"annotating-instance-and-class-methods",children:"Annotating instance and class methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"T = TypeVar('T', bound='Copyable')\nclass Copyable:\n    def copy(self: T) -> T:\n        # return a copy of self\n\nclass C(Copyable): ...\nc = C()\nc2 = c.copy()  # type here should be C\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"T = TypeVar('T', bound='C')\nclass C:\n    @classmethod\n    def factory(cls: Type[T]) -> T:\n        # make a new instance of cls\n\nclass D(C): ...\nd = D.factory()  # type here should be D\n"})}),"\n",(0,t.jsx)(n.h3,{id:"annotating-generator-functions-and-coroutines",children:"Annotating generator functions and coroutines"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"Generator[yield_type, send_type, return_type]"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def echo_round() -> Generator[int, float, str]:\n    res = yield\n    while res:\n        res = yield round(res)\n    return 'OK'\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"async def spam(ignored: int) -> str:\n    return 'spam'\n\nasync def foo() -> None:\n    bar = await spam(42)  # type: str\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import List, Coroutine\nc = None  # type: Coroutine[List[str], str, int]\n...\nx = c.send('hi')  # type: List[str]\nasync def bar() -> None:\n    x = await c  # type: int\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def op() -> typing.Awaitable[str]:\n    if cond:\n        return spam(42)\n    else:\n        return asyncio.Future(...)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"compatibility-with-other-uses-of-function-annotations",children:"Compatibility with other uses of function annotations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["a ",(0,t.jsx)(n.code,{children:"# type: ignore comment"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["a ",(0,t.jsx)(n.code,{children:"@no_type_check"})," decorator on a class or function;"]}),"\n",(0,t.jsxs)(n.li,{children:["a custom class or function decorator marked with ",(0,t.jsx)(n.code,{children:"@no_type_check_decorator"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"type-comments",children:"Type comments"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"x = []                # type: List[Employee]\nx, y, z = [], [], []  # type: List[int], List[int], List[str]\nx, y, z = [], [], []  # type: (List[int], List[int], List[str])\na, b, *c = range(5)   # type: float, float, List[float]\nx = [1, 2]            # type: List[int]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Type comments should be put on the last line of the statement that contains the variable definition. They can also be placed on with statements and for statements, right after the colon."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"with frobnicate() as foo:  # type: int\n    # Here foo is an int\n    ...\n\nfor x, y in points:  # type: float, float\n    # Here x and y are floats\n    ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This can be done using ",(0,t.jsx)(n.strong,{children:"PEP 526"})," variable annotation syntax"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import IO\n\nstream: IO[str]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"casts",children:"Casts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import List, cast\n\ndef find_first_str(a: List[object]) -> str:\n    index = next(i for i, x in enumerate(a) if isinstance(x, str))\n    # We only get here if there's at least one string in a\n    return cast(str, a[index])\n"})}),"\n",(0,t.jsx)(n.p,{children:"At runtime a cast always returns the expression unchanged \u2013 it does not check the type, and it does not convert or coerce the value"}),"\n",(0,t.jsx)(n.p,{children:"Casts differ from type comments (see the previous section). When using a type comment, the type checker should still verify that the inferred type is consistent with the stated type"}),"\n",(0,t.jsx)(n.h2,{id:"newtype-helper-function",children:"NewType helper function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"UserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -> str:\n    ...\n\nUserId('user')          # Fails type check\n\nname_by_id(42)          # Fails type check\nname_by_id(UserId(42))  # OK\n\nnum = UserId(5) + 1     # type: int\n"})}),"\n",(0,t.jsx)(n.h2,{id:"stub-files",children:"Stub Files"}),"\n",(0,t.jsxs)(n.p,{children:["Stub files are files containing type hints that are ",(0,t.jsx)(n.strong,{children:"only for use"})," by the type checker, not at runtime"]}),"\n",(0,t.jsx)(n.p,{children:"The type checker should only check function signatures in stub files; It is recommended that function bodies in stub files just be a single ellipsis (...)."}),"\n",(0,t.jsx)(n.p,{children:"The type checker should have a configurable search path for stub files. If a stub file is found the type checker should not read the corresponding \u201creal\u201d module"}),"\n",(0,t.jsxs)(n.p,{children:["While stub files are syntactically valid Python modules, they use the ",(0,t.jsx)(n.code,{children:".pyi"})," extension to make it possible to maintain stub files in the same directory as the corresponding real module"]}),"\n",(0,t.jsx)(n.h3,{id:"functionmethod-overloading",children:"Function/method overloading"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import overload\n\nclass bytes:\n    ...\n    @overload\n    def __getitem__(self, i: int) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import Callable, Iterable, Iterator, Tuple, TypeVar, overload\n\nT1 = TypeVar('T1')\nT2 = TypeVar('T2')\nS = TypeVar('S')\n\n@overload\ndef map(func: Callable[[T1], S], iter1: Iterable[T1]) -> Iterator[S]: ...\n@overload\ndef map(func: Callable[[T1, T2], S],\n        iter1: Iterable[T1], iter2: Iterable[T2]) -> Iterator[S]: ...\n# ... and we could add more items to support more than two iterables\n"})}),"\n",(0,t.jsx)(n.p,{children:"In regular modules, a series of @overload-decorated definitions must be followed by exactly one non-@overload-decorated definition (for the same function/method)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"@overload\ndef utf8(value: None) -> None:\n    pass\n@overload\ndef utf8(value: bytes) -> bytes:\n    pass\n@overload\ndef utf8(value: unicode) -> bytes:\n    pass\ndef utf8(value):\n    <actual implementation>\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from typing import TypeVar, Text\n\nAnyStr = TypeVar('AnyStr', Text, bytes)\n\ndef concat1(x: AnyStr, y: AnyStr) -> AnyStr: ...\n\n@overload\ndef concat2(x: str, y: str) -> str: ...\n@overload\ndef concat2(x: bytes, y: bytes) -> bytes: ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We ",(0,t.jsx)(n.strong,{children:"recommend"})," that ",(0,t.jsx)(n.code,{children:"@overload"})," is only used in cases where a type variable is not sufficient, due to its special stub-only status"]}),"\n",(0,t.jsx)(n.h2,{id:"the-typing-module",children:"The typing Module"}),"\n",(0,t.jsxs)(n.p,{children:["To open the usage of static type checking to Python 3.5 as well as older versions, a uniform namespace is required. For this purpose, a new module in the standard library is introduced called ",(0,t.jsx)(n.code,{children:"typing"})]}),"\n",(0,t.jsxs)(n.p,{children:["It defines the ",(0,t.jsx)(n.strong,{children:"fundamental building blocks"})," for constructing types (e.g. ",(0,t.jsx)(n.code,{children:"Any"}),"), types representing ",(0,t.jsx)(n.strong,{children:"generic variants of builtin collections"})," (e.g. ",(0,t.jsx)(n.code,{children:"List"}),"), types representing ",(0,t.jsx)(n.strong,{children:"generic collection ABCs"})," (e.g. ",(0,t.jsx)(n.code,{children:"Sequence"}),"), and a small collection of convenience definitions"]}),"\n",(0,t.jsx)(n.h3,{id:"fundamental-building-blocks",children:"Fundamental building blocks"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Any, used as ",(0,t.jsx)(n.code,{children:"def get(key: str) -> Any: ..."})]}),"\n",(0,t.jsxs)(n.li,{children:["Union, used as ",(0,t.jsx)(n.code,{children:"Union[Type1, Type2, Type3]"})]}),"\n",(0,t.jsxs)(n.li,{children:["Callable, used as ",(0,t.jsx)(n.code,{children:"Callable[[Arg1Type, Arg2Type], ReturnType]"})]}),"\n",(0,t.jsxs)(n.li,{children:["Tuple, used by listing the element types, for example ",(0,t.jsx)(n.code,{children:"Tuple[int, int, str]"}),". The empty tuple can be typed as ",(0,t.jsx)(n.code,{children:"Tuple[()]"}),". Arbitrary-length homogeneous tuples can be expressed using one type and ellipsis, for example ",(0,t.jsx)(n.code,{children:"Tuple[int, ...]"}),". (The ... here are part of the syntax, a literal ellipsis.)"]}),"\n",(0,t.jsxs)(n.li,{children:["TypeVar, used as ",(0,t.jsx)(n.code,{children:"X = TypeVar('X', Type1, Type2, Type3)"})," or simply ",(0,t.jsx)(n.code,{children:"Y = TypeVar('Y')"})," (see above for more details)"]}),"\n",(0,t.jsxs)(n.li,{children:["Generic, used to ",(0,t.jsx)(n.strong,{children:"create user-defined generic classes"})]}),"\n",(0,t.jsxs)(n.li,{children:["Type, used to ",(0,t.jsx)(n.strong,{children:"annotate class objects"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"generic-variants-of-builtin-collections",children:"Generic variants of builtin collections"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Dict, used as ",(0,t.jsx)(n.code,{children:"Dict[key_type, value_type]"})]}),"\n",(0,t.jsxs)(n.li,{children:["DefaultDict, used as ",(0,t.jsx)(n.code,{children:"DefaultDict[key_type, value_type]"}),", a generic variant of ",(0,t.jsx)(n.code,{children:"collections.defaultdict"})]}),"\n",(0,t.jsxs)(n.li,{children:["List, used as ",(0,t.jsx)(n.code,{children:"List[element_type]"})]}),"\n",(0,t.jsxs)(n.li,{children:["Set, used as ",(0,t.jsx)(n.code,{children:"Set[element_type]"}),". See remark for AbstractSet below."]}),"\n",(0,t.jsxs)(n.li,{children:["FrozenSet, used as ",(0,t.jsx)(n.code,{children:"FrozenSet[element_type]"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note: ",(0,t.jsx)(n.code,{children:"Dict"}),", ",(0,t.jsx)(n.code,{children:"DefaultDict"}),", ",(0,t.jsx)(n.code,{children:"List"}),", ",(0,t.jsx)(n.code,{children:"Set"})," and ",(0,t.jsx)(n.code,{children:"FrozenSet"})," are mainly useful for annotating return values. ",(0,t.jsx)(n.strong,{children:"For arguments, prefer"})," the abstract collection types defined below, e.g. ",(0,t.jsx)(n.code,{children:"Mapping"}),", ",(0,t.jsx)(n.code,{children:"Sequence"})," or ",(0,t.jsx)(n.code,{children:"AbstractSet"})]}),"\n",(0,t.jsx)(n.h3,{id:"generic-variants-of-container-abcs-and-a-few-non-containers",children:"Generic variants of container ABCs (and a few non-containers)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Awaitable"}),"\n",(0,t.jsx)(n.li,{children:"AsyncIterable"}),"\n",(0,t.jsx)(n.li,{children:"AsyncIterator"}),"\n",(0,t.jsx)(n.li,{children:"ByteString"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Callable"})," (see above, listed here for completeness)"]}),"\n",(0,t.jsx)(n.li,{children:"Collection"}),"\n",(0,t.jsx)(n.li,{children:"Container"}),"\n",(0,t.jsx)(n.li,{children:"ContextManager"}),"\n",(0,t.jsx)(n.li,{children:"Coroutine"}),"\n",(0,t.jsxs)(n.li,{children:["Generator, used as ",(0,t.jsx)(n.code,{children:"Generator[yield_type, send_type, return_type]"}),". This represents the return value of generator functions. It is a subtype of ",(0,t.jsx)(n.code,{children:"Iterable"})," and it has additional type variables for the type accepted by the ",(0,t.jsx)(n.code,{children:"send()"})," method (it is contravariant in this variable \u2013 a generator that accepts sending it Employee instance is valid in a context where a generator is required that accepts sending it Manager instances) and the return type of the generator."]}),"\n",(0,t.jsx)(n.li,{children:"Hashable (not generic, but present for completeness)"}),"\n",(0,t.jsx)(n.li,{children:"ItemsView"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Iterable"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Iterator"})}),"\n",(0,t.jsx)(n.li,{children:"KeysView"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Mapping"})}),"\n",(0,t.jsx)(n.li,{children:"MappingView"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"MutableMapping"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"MutableSequence"})}),"\n",(0,t.jsx)(n.li,{children:"MutableSet"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Sequence"})}),"\n",(0,t.jsxs)(n.li,{children:["Set, renamed to ",(0,t.jsx)(n.code,{children:"AbstractSet"}),". This name change was required because Set in the typing module means set() with generics."]}),"\n",(0,t.jsx)(n.li,{children:"Sized (not generic, but present for completeness)"}),"\n",(0,t.jsx)(n.li,{children:"ValuesView"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"convenience-definitions",children:"Convenience definitions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Optional, defined by ",(0,t.jsx)(n.code,{children:"Optional[t] == Union[t, None]"})]}),"\n",(0,t.jsxs)(n.li,{children:["Text, a simple alias for ",(0,t.jsx)(n.code,{children:"str"})," in Python 3, for ",(0,t.jsx)(n.code,{children:"unicode"})," in Python 2"]}),"\n",(0,t.jsxs)(n.li,{children:["AnyStr, defined as ",(0,t.jsx)(n.code,{children:"TypeVar('AnyStr', Text, bytes)"})]}),"\n",(0,t.jsxs)(n.li,{children:["NamedTuple, used as ",(0,t.jsx)(n.code,{children:"NamedTuple(type_name, [(field_name, field_type), ...])"})," and equivalent to collections.namedtuple(type_name, [field_name, ...]). This is useful to declare the types of the fields of a named tuple type."]}),"\n",(0,t.jsxs)(n.li,{children:["NewType, used to create unique types with little runtime overhead ",(0,t.jsx)(n.code,{children:"UserId = NewType('UserId', int)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cast()"}),", described earlier"]}),"\n",(0,t.jsx)(n.li,{children:"@no_type_check, a decorator to disable type checking per class or function (see below)"}),"\n",(0,t.jsx)(n.li,{children:"@no_type_check_decorator, a decorator to create your own decorators with the same meaning as @no_type_check (see below)"}),"\n",(0,t.jsx)(n.li,{children:"@type_check_only, a decorator only available during type checking for use in stub files (see above); marks a class or function as unavailable during runtime"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"@overload"}),", described earlier"]}),"\n",(0,t.jsxs)(n.li,{children:["get_type_hints(), a utility function to retrieve the type hints from a function or method. Given a function or method object, it returns a dict with the same format as ",(0,t.jsx)(n.code,{children:"__annotations__"}),", but evaluating forward references (which are given as string literals) as expressions in the context of the original function or method definition."]}),"\n",(0,t.jsx)(n.li,{children:"TYPE_CHECKING, False at runtime but True to type checkers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"io-related-types",children:"I/O related types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["IO (generic over ",(0,t.jsx)(n.code,{children:"AnyStr"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["BinaryIO (a simple subtype of ",(0,t.jsx)(n.code,{children:"IO[bytes]"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["TextIO (a simple subtype of ",(0,t.jsx)(n.code,{children:"IO[str]"}),")"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);