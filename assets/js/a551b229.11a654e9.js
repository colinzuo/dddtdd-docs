"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[160],{32815:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var n=r(74848),o=r(28453);const i={},c=void 0,a={id:"programming-languages/golang/gin/recovery",title:"recovery",description:"RecoveryFunc",source:"@site/docs/00400-programming-languages/golang/gin/0500-recovery.md",sourceDirName:"00400-programming-languages/golang/gin",slug:"/programming-languages/golang/gin/recovery",permalink:"/dddtdd-docs/programming-languages/golang/gin/recovery",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:500,frontMatter:{},sidebar:"docSidebar",previous:{title:"errors",permalink:"/dddtdd-docs/programming-languages/golang/gin/errors"},next:{title:"routergroup",permalink:"/dddtdd-docs/programming-languages/golang/gin/routergroup"}},s={},l=[{value:"RecoveryFunc",id:"recoveryfunc",level:2},{value:"Recovery",id:"recovery",level:2},{value:"RecoveryWithWriter",id:"recoverywithwriter",level:2},{value:"CustomRecoveryWithWriter",id:"customrecoverywithwriter",level:2},{value:"defaultHandleRecovery",id:"defaulthandlerecovery",level:2}];function d(t){const e={code:"code",h2:"h2",pre:"pre",...(0,o.R)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{id:"recoveryfunc",children:"RecoveryFunc"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:"// RecoveryFunc defines the function passable to CustomRecovery.\ntype RecoveryFunc func(c *Context, err any)\n"})}),"\n",(0,n.jsx)(e.h2,{id:"recovery",children:"Recovery"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:"// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.\nfunc Recovery() HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter)\n}\n"})}),"\n",(0,n.jsx)(e.h2,{id:"recoverywithwriter",children:"RecoveryWithWriter"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:"// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.\nfunc RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {\n\tif len(recovery) > 0 {\n\t\treturn CustomRecoveryWithWriter(out, recovery[0])\n\t}\n\treturn CustomRecoveryWithWriter(out, defaultHandleRecovery)\n}\n"})}),"\n",(0,n.jsx)(e.h2,{id:"customrecoverywithwriter",children:"CustomRecoveryWithWriter"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:'// CustomRecoveryWithWriter returns a middleware for a given writer that recovers from any panics and calls the provided handle func to handle it.\nfunc CustomRecoveryWithWriter(out io.Writer, handle RecoveryFunc) HandlerFunc {\n\tvar logger *log.Logger\n\tif out != nil {\n\t\tlogger = log.New(out, "\\n\\n\\x1b[31m", log.LstdFlags)\n\t}\n\treturn func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// Check for a broken connection, as it is not really a\n\t\t\t\t// condition that warrants a panic stack trace.\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tvar se *os.SyscallError\n\t\t\t\t\tif errors.As(ne, &se) {\n\t\t\t\t\t\tseStr := strings.ToLower(se.Error())\n\t\t\t\t\t\tif strings.Contains(seStr, "broken pipe") ||\n\t\t\t\t\t\t\tstrings.Contains(seStr, "connection reset by peer") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif logger != nil {\n\t\t\t\t\tstack := stack(3)\n\t\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\t\t\t\t\theaders := strings.Split(string(httpRequest), "\\r\\n")\n\t\t\t\t\tfor idx, header := range headers {\n\t\t\t\t\t\tcurrent := strings.Split(header, ":")\n\t\t\t\t\t\tif current[0] == "Authorization" {\n\t\t\t\t\t\t\theaders[idx] = current[0] + ": *"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theadersToStr := strings.Join(headers, "\\r\\n")\n\t\t\t\t\tif brokenPipe {\n\t\t\t\t\t\tlogger.Printf("%s\\n%s%s", err, headersToStr, reset)\n\t\t\t\t\t} else if IsDebugging() {\n\t\t\t\t\t\tlogger.Printf("[Recovery] %s panic recovered:\\n%s\\n%s\\n%s%s",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), headersToStr, err, stack, reset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.Printf("[Recovery] %s panic recovered:\\n%s\\n%s%s",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), err, stack, reset)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// If the connection is dead, we can\'t write a status to it.\n\t\t\t\t\tc.Error(err.(error)) //nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n'})}),"\n",(0,n.jsx)(e.h2,{id:"defaulthandlerecovery",children:"defaultHandleRecovery"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:"func defaultHandleRecovery(c *Context, _ any) {\n\tc.AbortWithStatus(http.StatusInternalServerError)\n}\n"})})]})}function u(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}},28453:(t,e,r)=>{r.d(e,{R:()=>c,x:()=>a});var n=r(96540);const o={},i=n.createContext(o);function c(t){const e=n.useContext(i);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:c(t.components),n.createElement(i.Provider,{value:e},t.children)}}}]);