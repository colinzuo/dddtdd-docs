"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[82586],{2391:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var r=t(74848),s=t(28453);const o={},i="Descriptor Guide",a={id:"programming-languages/python/how-to/descriptor",title:"Descriptor Guide",description:"https://docs.python.org/3/howto/descriptor.html",source:"@site/docs/00400-programming-languages/python/how-to/descriptor.md",sourceDirName:"00400-programming-languages/python/how-to",slug:"/programming-languages/python/how-to/descriptor",permalink:"/dddtdd-docs/programming-languages/python/how-to/descriptor",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1733377229e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Building C and C++ Extensions",permalink:"/dddtdd-docs/programming-languages/python/extending/building"},next:{title:"enum",permalink:"/dddtdd-docs/programming-languages/python/how-to/enum"}},c={},d=[{value:"Primer",id:"primer",level:2},{value:"Managed attributes",id:"managed-attributes",level:3},{value:"Customized names",id:"customized-names",level:3},{value:"Closing thoughts",id:"closing-thoughts",level:3},{value:"Technical Tutorial",id:"technical-tutorial",level:2},{value:"Definition and introduction",id:"definition-and-introduction",level:3},{value:"Descriptor protocol",id:"descriptor-protocol",level:3},{value:"Invocation from an instance",id:"invocation-from-an-instance",level:3},{value:"Summary of invocation logic",id:"summary-of-invocation-logic",level:3},{value:"Automatic name notification",id:"automatic-name-notification",level:3},{value:"ORM example",id:"orm-example",level:3},{value:"Pure Python Equivalents",id:"pure-python-equivalents",level:2},{value:"Properties",id:"properties",level:3},{value:"Functions and methods",id:"functions-and-methods",level:3},{value:"Static methods",id:"static-methods",level:3},{value:"Class methods",id:"class-methods",level:3},{value:"Member objects and <strong>slots</strong>",id:"member-objects-and-slots",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"descriptor-guide",children:"Descriptor Guide"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://docs.python.org/3/howto/descriptor.html",children:"https://docs.python.org/3/howto/descriptor.html"})}),"\n",(0,r.jsx)(n.h2,{id:"primer",children:"Primer"}),"\n",(0,r.jsx)(n.h3,{id:"managed-attributes",children:"Managed attributes"}),"\n",(0,r.jsxs)(n.p,{children:["A popular use for descriptors is ",(0,r.jsx)(n.strong,{children:"managing access to instance data"}),". The descriptor is assigned to a public attribute in the class dictionary while the ",(0,r.jsx)(n.strong,{children:"actual data is stored as a private attribute"})," in the instance dictionary. The descriptor\u2019s ",(0,r.jsx)(n.code,{children:"__get__()"})," and ",(0,r.jsx)(n.code,{children:"__set__()"})," methods are triggered when the ",(0,r.jsx)(n.strong,{children:"public attribute is accessed"})]}),"\n",(0,r.jsx)(n.h3,{id:"customized-names",children:"Customized names"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"class LoggedAccess:\r\n\r\n    def __set_name__(self, owner, name):\r\n        self.public_name = name\r\n        self.private_name = '_' + name\n"})}),"\n",(0,r.jsx)(n.h3,{id:"closing-thoughts",children:"Closing thoughts"}),"\n",(0,r.jsxs)(n.p,{children:["Descriptors are used throughout the language. It is how functions turn into bound methods. Common tools like ",(0,r.jsx)(n.code,{children:"classmethod()"}),", ",(0,r.jsx)(n.code,{children:"staticmethod()"}),", ",(0,r.jsx)(n.code,{children:"property()"}),", and ",(0,r.jsx)(n.code,{children:"functools.cached_property()"})," are all implemented as descriptors"]}),"\n",(0,r.jsx)(n.h2,{id:"technical-tutorial",children:"Technical Tutorial"}),"\n",(0,r.jsx)(n.h3,{id:"definition-and-introduction",children:"Definition and introduction"}),"\n",(0,r.jsxs)(n.p,{children:["In general, a descriptor is an attribute value that has one of the methods in the descriptor protocol. Those methods are ",(0,r.jsx)(n.code,{children:"__get__()"}),", ",(0,r.jsx)(n.code,{children:"__set__()"}),", and ",(0,r.jsx)(n.code,{children:"__delete__()"}),". If any of those methods are defined for an attribute, it is ",(0,r.jsx)(n.strong,{children:"said to be a descriptor"})]}),"\n",(0,r.jsx)(n.h3,{id:"descriptor-protocol",children:"Descriptor protocol"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"descr.__get__(self, obj, type=None)\r\n\r\ndescr.__set__(self, obj, value)\r\n\r\ndescr.__delete__(self, obj)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If an object defines ",(0,r.jsx)(n.code,{children:"__set__()"})," or ",(0,r.jsx)(n.code,{children:"__delete__()"}),", it is considered a ",(0,r.jsx)(n.strong,{children:"data descriptor"}),". Descriptors that only define ",(0,r.jsx)(n.code,{children:"__get__()"})," are called ",(0,r.jsx)(n.strong,{children:"non-data descriptors"})," (they are often used for methods but other uses are possible)"]}),"\n",(0,r.jsxs)(n.p,{children:["If an instance\u2019s dictionary has an entry with the same name as a data descriptor, the data descriptor ",(0,r.jsx)(n.strong,{children:"takes precedence"}),". If an instance\u2019s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry ",(0,r.jsx)(n.strong,{children:"takes precedence"})]}),"\n",(0,r.jsx)(n.h3,{id:"invocation-from-an-instance",children:"Invocation from an instance"}),"\n",(0,r.jsxs)(n.p,{children:["Instance lookup scans through a chain of namespaces giving ",(0,r.jsx)(n.strong,{children:"data descriptors"})," the highest priority, followed by ",(0,r.jsx)(n.strong,{children:"instance variables"}),", then ",(0,r.jsx)(n.strong,{children:"non-data descriptors"}),", then ",(0,r.jsx)(n.strong,{children:"class variables"}),", and lastly ",(0,r.jsx)(n.code,{children:"__getattr__()"})," if it is provided"]}),"\n",(0,r.jsxs)(n.p,{children:["The logic for a dotted lookup is in ",(0,r.jsx)(n.code,{children:"object.__getattribute__()"}),". Here is a pure Python equivalent:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"def find_name_in_mro(cls, name, default):\r\n    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\r\n    for base in cls.__mro__:\r\n        if name in vars(base):\r\n            return vars(base)[name]\r\n    return default\r\n\r\ndef object_getattribute(obj, name):\r\n    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\r\n    null = object()\r\n    objtype = type(obj)\r\n    cls_var = find_name_in_mro(objtype, name, null)\r\n    descr_get = getattr(type(cls_var), '__get__', null)\r\n    if descr_get is not null:\r\n        if (hasattr(type(cls_var), '__set__')\r\n            or hasattr(type(cls_var), '__delete__')):\r\n            return descr_get(cls_var, obj, objtype)     # data descriptor\r\n    if hasattr(obj, '__dict__') and name in vars(obj):\r\n        return vars(obj)[name]                          # instance variable\r\n    if descr_get is not null:\r\n        return descr_get(cls_var, obj, objtype)         # non-data descriptor\r\n    if cls_var is not null:\r\n        return cls_var                                  # class variable\r\n    raise AttributeError(name)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note, there is no ",(0,r.jsx)(n.code,{children:"__getattr__()"})," hook in the ",(0,r.jsx)(n.code,{children:"__getattribute__()"})," code. That is why calling ",(0,r.jsx)(n.code,{children:"__getattribute__()"})," directly or with ",(0,r.jsx)(n.code,{children:"super().__getattribute__"})," will bypass ",(0,r.jsx)(n.code,{children:"__getattr__()"})," entirely."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, it is the dot operator and the ",(0,r.jsx)(n.code,{children:"getattr()"})," function that are responsible for invoking ",(0,r.jsx)(n.code,{children:"__getattr__()"})," whenever ",(0,r.jsx)(n.code,{children:"__getattribute__()"})," raises an ",(0,r.jsx)(n.code,{children:"AttributeError"}),". Their logic is encapsulated in a helper function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"def getattr_hook(obj, name):\r\n    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\r\n    try:\r\n        return obj.__getattribute__(name)\r\n    except AttributeError:\r\n        if not hasattr(type(obj), '__getattr__'):\r\n            raise\r\n    return type(obj).__getattr__(obj, name)             # __getattr__\n"})}),"\n",(0,r.jsx)(n.h3,{id:"summary-of-invocation-logic",children:"Summary of invocation logic"}),"\n",(0,r.jsx)(n.p,{children:"The important points to remember are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Descriptors are invoked by the ",(0,r.jsx)(n.code,{children:"__getattribute__()"})," method."]}),"\n",(0,r.jsxs)(n.li,{children:["Classes inherit this machinery from ",(0,r.jsx)(n.code,{children:"object, type, or super()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Overriding ",(0,r.jsx)(n.code,{children:"__getattribute__()"})," prevents automatic descriptor calls because all the descriptor logic is in that method."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"object.__getattribute__()"})," and ",(0,r.jsx)(n.code,{children:"type.__getattribute__()"})," make different calls to ",(0,r.jsx)(n.code,{children:"__get__()"}),". The first includes the instance and may include the class. The second puts in ",(0,r.jsx)(n.code,{children:"None"})," for the instance and always includes the class."]}),"\n",(0,r.jsx)(n.li,{children:"Data descriptors always override instance dictionaries."}),"\n",(0,r.jsx)(n.li,{children:"Non-data descriptors may be overridden by instance dictionaries."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"automatic-name-notification",children:"Automatic name notification"}),"\n",(0,r.jsxs)(n.p,{children:["When a new class is created, the ",(0,r.jsx)(n.code,{children:"type"})," metaclass scans the dictionary of the new class. If any of the entries are descriptors and if they define ",(0,r.jsx)(n.code,{children:"__set_name__()"}),", that method is called with two arguments. The ",(0,r.jsx)(n.strong,{children:"owner"})," is the class where the descriptor is used, and the ",(0,r.jsx)(n.strong,{children:"name"})," is the class variable the descriptor was assigned to"]}),"\n",(0,r.jsx)(n.h3,{id:"orm-example",children:"ORM example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"class Field:\r\n\r\n    def __set_name__(self, owner, name):\r\n        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'\r\n        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'\r\n\r\n    def __get__(self, obj, objtype=None):\r\n        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\r\n\r\n    def __set__(self, obj, value):\r\n        conn.execute(self.store, [value, obj.key])\r\n        conn.commit()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pure-python-equivalents",children:"Pure Python Equivalents"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Properties"}),", ",(0,r.jsx)(n.code,{children:"bound methods"}),", ",(0,r.jsx)(n.code,{children:"static methods"}),", ",(0,r.jsx)(n.code,{children:"class methods"}),", and ",(0,r.jsx)(n.code,{children:"__slots__"})," are all based on the descriptor protocol"]}),"\n",(0,r.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"property(fget=None, fset=None, fdel=None, doc=None) -> property\n"})}),"\n",(0,r.jsx)(n.h3,{id:"functions-and-methods",children:"Functions and methods"}),"\n",(0,r.jsxs)(n.p,{children:["Functions stored in ",(0,r.jsx)(n.strong,{children:"class dictionaries"})," get turned into methods when invoked. Methods only differ from regular functions in that the object instance is prepended to the other arguments. By convention, the instance is called ",(0,r.jsx)(n.code,{children:"self"})," but could be called this or any other variable name"]}),"\n",(0,r.jsxs)(n.p,{children:["Methods can be created manually with ",(0,r.jsx)(n.code,{children:"types.MethodType"})," which is roughly equivalent to:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'class MethodType:\r\n    "Emulate PyMethod_Type in Objects/classobject.c"\r\n\r\n    def __init__(self, func, obj):\r\n        self.__func__ = func\r\n        self.__self__ = obj\r\n\r\n    def __call__(self, *args, **kwargs):\r\n        func = self.__func__\r\n        obj = self.__self__\r\n        return func(obj, *args, **kwargs)\r\n\r\n    def __getattribute__(self, name):\r\n        "Emulate method_getset() in Objects/classobject.c"\r\n        if name == \'__doc__\':\r\n            return self.__func__.__doc__\r\n        return object.__getattribute__(self, name)\r\n\r\n    def __getattr__(self, name):\r\n        "Emulate method_getattro() in Objects/classobject.c"\r\n        return getattr(self.__func__, name)\r\n\r\n    def __get__(self, obj, objtype=None):\r\n        "Emulate method_descr_get() in Objects/classobject.c"\r\n        return self\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To support automatic creation of methods, functions include the ",(0,r.jsx)(n.code,{children:"__get__()"})," method for binding methods during attribute access. This means that functions are non-data descriptors that return bound methods during dotted lookup from an instance. Here\u2019s how it works:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'class Function:\r\n    ...\r\n\r\n    def __get__(self, obj, objtype=None):\r\n        "Simulate func_descr_get() in Objects/funcobject.c"\r\n        if obj is None:\r\n            return self\r\n        return MethodType(self, obj)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"static-methods",children:"Static methods"}),"\n",(0,r.jsxs)(n.p,{children:["Using the non-data descriptor protocol, a pure Python version of ",(0,r.jsx)(n.code,{children:"staticmethod()"})," would look like this"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'import functools\r\n\r\nclass StaticMethod:\r\n    "Emulate PyStaticMethod_Type() in Objects/funcobject.c"\r\n\r\n    def __init__(self, f):\r\n        self.f = f\r\n        functools.update_wrapper(self, f)\r\n\r\n    def __get__(self, obj, objtype=None):\r\n        return self.f\r\n\r\n    def __call__(self, *args, **kwds):\r\n        return self.f(*args, **kwds)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"class-methods",children:"Class methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'import functools\r\n\r\nclass ClassMethod:\r\n    "Emulate PyClassMethod_Type() in Objects/funcobject.c"\r\n\r\n    def __init__(self, f):\r\n        self.f = f\r\n        functools.update_wrapper(self, f)\r\n\r\n    def __get__(self, obj, cls=None):\r\n        if cls is None:\r\n            cls = type(obj)\r\n        return MethodType(self.f, cls)\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"member-objects-and-slots",children:["Member objects and ",(0,r.jsx)(n.strong,{children:"slots"})]}),"\n",(0,r.jsxs)(n.p,{children:["When a class defines ",(0,r.jsx)(n.code,{children:"__slots__"}),", it replaces instance dictionaries with a ",(0,r.jsx)(n.strong,{children:"fixed-length array"})," of slot values"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);