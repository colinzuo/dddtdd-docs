"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[26742],{63880:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var t=a(74848),r=a(28453);const i={},s="Types",o={id:"programming-languages/python/libs/pydantic/types",title:"Types",description:"There are also more complex types that can be found in the Pydantic Extra Types package",source:"@site/docs/00400-programming-languages/python/libs/pydantic/030-types.md",sourceDirName:"00400-programming-languages/python/libs/pydantic",slug:"/programming-languages/python/libs/pydantic/types",permalink:"/dddtdd-docs/programming-languages/python/libs/pydantic/types",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1734870983e3,sidebarPosition:30,frontMatter:{},sidebar:"docSidebar",previous:{title:"Fields",permalink:"/dddtdd-docs/programming-languages/python/libs/pydantic/fields"},next:{title:"Configuration",permalink:"/dddtdd-docs/programming-languages/python/libs/pydantic/config"}},c={},d=[{value:"Custom Types",id:"custom-types",level:2},{value:"Composing types via <code>Annotated</code>",id:"composing-types-via-annotated",level:3},{value:"Customizing validation with <code>__get_pydantic_core_schema__</code>",id:"customizing-validation-with-__get_pydantic_core_schema__",level:3},{value:"As a method on a custom type",id:"as-a-method-on-a-custom-type",level:4},{value:"As an annotation",id:"as-an-annotation",level:4},{value:"Handling third-party types",id:"handling-third-party-types",level:4},{value:"Summary",id:"summary",level:4}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"types",children:"Types"}),"\n",(0,t.jsxs)(n.p,{children:["There are also more complex types that can be found in the ",(0,t.jsx)(n.a,{href:"https://github.com/pydantic/pydantic-extra-types",children:"Pydantic Extra Types"})," package"]}),"\n",(0,t.jsx)(n.h2,{id:"custom-types",children:"Custom Types"}),"\n",(0,t.jsxs)(n.h3,{id:"composing-types-via-annotated",children:["Composing types via ",(0,t.jsx)(n.code,{children:"Annotated"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"PositiveInt = Annotated[int, Field(gt=0)]\r\n\r\nta = TypeAdapter(PositiveInt)\r\n\r\nprint(ta.validate_python(1))\r\n#> 1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from pydantic import (\r\n    AfterValidator,\r\n    PlainSerializer,\r\n    TypeAdapter,\r\n    WithJsonSchema,\r\n)\r\n\r\nTruncatedFloat = Annotated[\r\n    float,\r\n    AfterValidator(lambda x: round(x, 1)),\r\n    PlainSerializer(lambda x: f'{x:.1e}', return_type=str),\r\n    WithJsonSchema({'type': 'string'}, mode='serialization'),\r\n]\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"customizing-validation-with-__get_pydantic_core_schema__",children:["Customizing validation with ",(0,t.jsx)(n.code,{children:"__get_pydantic_core_schema__"})]}),"\n",(0,t.jsxs)(n.p,{children:["You can implement ",(0,t.jsx)(n.code,{children:"__get_pydantic_core_schema__"}),' both on a custom type and on metadata intended to be put in Annotated. In both cases the API is middleware-like and similar to that of "wrap" validators: you get a ',(0,t.jsx)(n.code,{children:"source_type"})," (which isn't necessarily the same as the class, in particular for generics) and a ",(0,t.jsx)(n.code,{children:"handler"})," that you can call with a type to either call the next metadata in ",(0,t.jsx)(n.code,{children:"Annotated"})," or call into Pydantic's internal schema generation"]}),"\n",(0,t.jsx)(n.h4,{id:"as-a-method-on-a-custom-type",children:"As a method on a custom type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"from pydantic_core import CoreSchema, core_schema\r\n\r\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\r\n\r\n\r\nclass Username(str):\r\n    @classmethod\r\n    def __get_pydantic_core_schema__(\r\n        cls, source_type: Any, handler: GetCoreSchemaHandler\r\n    ) -> CoreSchema:\r\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n"})}),"\n",(0,t.jsx)(n.h4,{id:"as-an-annotation",children:"As an annotation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"@dataclass(frozen=True)  \r\nclass MyAfterValidator:\r\n    func: Callable[[Any], Any]\r\n\r\n    def __get_pydantic_core_schema__(\r\n        self, source_type: Any, handler: GetCoreSchemaHandler\r\n    ) -> CoreSchema:\r\n        return core_schema.no_info_after_validator_function(\r\n            self.func, handler(source_type)\r\n        )\r\n\r\n\r\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"handling-third-party-types",children:"Handling third-party types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'class ThirdPartyType:\r\n    """\r\n    This is meant to represent a type from a third-party library that wasn\'t designed with Pydantic\r\n    integration in mind, and so doesn\'t have a `pydantic_core.CoreSchema` or anything.\r\n    """\r\n\r\n    x: int\r\n\r\n    def __init__(self):\r\n        self.x = 0\r\n\r\n\r\nclass _ThirdPartyTypePydanticAnnotation:\r\n    @classmethod\r\n    def __get_pydantic_core_schema__(\r\n        cls,\r\n        _source_type: Any,\r\n        _handler: GetCoreSchemaHandler,\r\n    ) -> core_schema.CoreSchema:\r\n        """\r\n        We return a pydantic_core.CoreSchema that behaves in the following ways:\r\n\r\n        * ints will be parsed as `ThirdPartyType` instances with the int as the x attribute\r\n        * `ThirdPartyType` instances will be parsed as `ThirdPartyType` instances without any changes\r\n        * Nothing else will pass validation\r\n        * Serialization will always return just an int\r\n        """\r\n\r\n        def validate_from_int(value: int) -> ThirdPartyType:\r\n            result = ThirdPartyType()\r\n            result.x = value\r\n            return result\r\n\r\n        from_int_schema = core_schema.chain_schema(\r\n            [\r\n                core_schema.int_schema(),\r\n                core_schema.no_info_plain_validator_function(validate_from_int),\r\n            ]\r\n        )\r\n\r\n        return core_schema.json_or_python_schema(\r\n            json_schema=from_int_schema,\r\n            python_schema=core_schema.union_schema(\r\n                [\r\n                    # check if it\'s an instance first before doing any further work\r\n                    core_schema.is_instance_schema(ThirdPartyType),\r\n                    from_int_schema,\r\n                ]\r\n            ),\r\n            serialization=core_schema.plain_serializer_function_ser_schema(\r\n                lambda instance: instance.x\r\n            ),\r\n        )\r\n\r\n    @classmethod\r\n    def __get_pydantic_json_schema__(\r\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\r\n    ) -> JsonSchemaValue:\r\n        # Use the same schema that would be used for `int`\r\n        return handler(core_schema.int_schema())\r\n\r\n\r\n# We now create an `Annotated` wrapper that we\'ll use as the annotation for fields on `BaseModel`s, etc.\r\nPydanticThirdPartyType = Annotated[\r\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\r\n]\n'})}),"\n",(0,t.jsx)(n.h4,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pydantic provides high level hooks to customize types via ",(0,t.jsx)(n.code,{children:"Annotated"})," like ",(0,t.jsx)(n.code,{children:"AfterValidator"})," and ",(0,t.jsx)(n.code,{children:"Field"}),". Use these when possible."]}),"\n",(0,t.jsxs)(n.li,{children:["Under the hood these use ",(0,t.jsx)(n.code,{children:"pydantic-core"})," to customize validation, and you can hook into that directly using ",(0,t.jsx)(n.code,{children:"GetPydanticSchema"})," or a marker class with ",(0,t.jsx)(n.code,{children:"__get_pydantic_core_schema__"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If you really want a custom type you can implement ",(0,t.jsx)(n.code,{children:"__get_pydantic_core_schema__"})," on the type itself"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var t=a(96540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);