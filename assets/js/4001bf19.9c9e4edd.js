"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[35404],{41128:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=r(74848),t=r(28453);const s={},o=void 0,a={id:"topic/grpc/grpc-go",title:"grpc-go",description:"Quick start",source:"@site/docs/00800-topic/grpc/120-grpc-go.md",sourceDirName:"00800-topic/grpc",slug:"/topic/grpc/grpc-go",permalink:"/dddtdd-docs/topic/grpc/grpc-go",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:120,frontMatter:{},sidebar:"docSidebar",previous:{title:"grpc",permalink:"/dddtdd-docs/topic/grpc/grpc"},next:{title:"grpc-go-pkg",permalink:"/dddtdd-docs/topic/grpc/grpc-go-pkg"}},l={},c=[{value:"Quick start",id:"quick-start",level:2},{value:"Regenerate gRPC code",id:"regenerate-grpc-code",level:3},{value:"Basics tutorial",id:"basics-tutorial",level:2},{value:"Server-side streaming RPC",id:"server-side-streaming-rpc",level:3},{value:"Client-side streaming RPC",id:"client-side-streaming-rpc",level:3},{value:"Bidirectional streaming RPC",id:"bidirectional-streaming-rpc",level:3},{value:"Starting the server",id:"starting-the-server",level:3},{value:"Creating the client",id:"creating-the-client",level:3},{value:"Client-side streaming RPC",id:"client-side-streaming-rpc-1",level:3},{value:"Bidirectional streaming RPC",id:"bidirectional-streaming-rpc-1",level:3},{value:"Generated-code reference",id:"generated-code-reference",level:2},{value:"Methods on generated server interfaces",id:"methods-on-generated-server-interfaces",level:3},{value:"Server-streaming methods",id:"server-streaming-methods",level:4},{value:"Client-streaming methods",id:"client-streaming-methods",level:4},{value:"Bidi-streaming methods",id:"bidi-streaming-methods",level:4},{value:"Methods on generated client interfaces",id:"methods-on-generated-client-interfaces",level:3},{value:"Unary Methods",id:"unary-methods",level:4},{value:"Guides",id:"guides",level:2},{value:"Cancellation",id:"cancellation",level:3},{value:"Deadlines",id:"deadlines",level:3},{value:"Deadlines on the Client",id:"deadlines-on-the-client",level:4},{value:"Deadlines on the Server",id:"deadlines-on-the-server",level:4},{value:"Error handling",id:"error-handling",level:3},{value:"General errors",id:"general-errors",level:4},{value:"Network failures",id:"network-failures",level:4},{value:"Protocol errors",id:"protocol-errors",level:4},{value:"Flow Control",id:"flow-control",level:3},{value:"Health Checking",id:"health-checking",level:3},{value:"Keepalive",id:"keepalive",level:3},{value:"Common situations where keepalives can be useful",id:"common-situations-where-keepalives-can-be-useful",level:4},{value:"Keepalive configuration specification",id:"keepalive-configuration-specification",level:4},{value:"A8-client-side-keepalive",id:"a8-client-side-keepalive",level:4},{value:"Metadata",id:"metadata",level:3},{value:"Performance Best Practices",id:"performance-best-practices",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://grpc.io/docs/languages/go/quickstart/",children:"https://grpc.io/docs/languages/go/quickstart/"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n"})}),"\n",(0,i.jsx)(n.h3,{id:"regenerate-grpc-code",children:"Regenerate gRPC code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"protoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    helloworld/helloworld.proto\n"})}),"\n",(0,i.jsx)(n.h2,{id:"basics-tutorial",children:"Basics tutorial"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://grpc.io/docs/languages/go/basics/",children:"https://grpc.io/docs/languages/go/basics/"})}),"\n",(0,i.jsx)(n.h3,{id:"server-side-streaming-rpc",children:"Server-side streaming RPC"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {\n  for _, feature := range s.savedFeatures {\n    if inRange(feature.Location, rect) {\n      if err := stream.Send(feature); err != nil {\n        return err\n      }\n    }\n  }\n  return nil\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, as in our simple RPC, we return a nil error to tell gRPC that we\u2019ve finished writing responses. Should any error happen in this call, we return a non-nil error; the gRPC layer will translate it into an appropriate RPC status to be sent on the wire"}),"\n",(0,i.jsx)(n.h3,{id:"client-side-streaming-rpc",children:"Client-side streaming RPC"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error {\n\n    point, err := stream.Recv()\n\n      return stream.SendAndClose(&pb.RouteSummary{\n        PointCount:   pointCount,\n        FeatureCount: featureCount,\n        Distance:     distance,\n        ElapsedTime:  int32(endTime.Sub(startTime).Seconds()),\n      })\n"})}),"\n",(0,i.jsx)(n.h3,{id:"bidirectional-streaming-rpc",children:"Bidirectional streaming RPC"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error {\n\n    in, err := stream.Recv()\n    \n      if err := stream.Send(note); err != nil {    \n"})}),"\n",(0,i.jsx)(n.h3,{id:"starting-the-server",children:"Starting the server"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'flag.Parse()\nlis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", *port))\nif err != nil {\n  log.Fatalf("failed to listen: %v", err)\n}\nvar opts []grpc.ServerOption\n...\ngrpcServer := grpc.NewServer(opts...)\npb.RegisterRouteGuideServer(grpcServer, newServer())\ngrpcServer.Serve(lis)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"creating-the-client",children:"Creating the client"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"var opts []grpc.DialOption\n...\nconn, err := grpc.Dial(*serverAddr, opts...)\nif err != nil {\n  ...\n}\ndefer conn.Close()\n\n\nclient := pb.NewRouteGuideClient(conn)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"client-side-streaming-rpc-1",children:"Client-side streaming RPC"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"stream, err := client.RecordRoute(context.Background())\n\nfor _, point := range points {\n  if err := stream.Send(point); err != nil {\n\nreply, err := stream.CloseAndRecv()    \n"})}),"\n",(0,i.jsx)(n.h3,{id:"bidirectional-streaming-rpc-1",children:"Bidirectional streaming RPC"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"stream, err := client.RouteChat(context.Background())\nwaitc := make(chan struct{})\ngo func() {\n  for {\n    in, err := stream.Recv()\n    if err == io.EOF {\n      // read done.\n      close(waitc)\n      return\n    }\n\nfor _, note := range notes {\n  if err := stream.Send(note); err != nil {\n    \nstream.CloseSend()\n<-waitc    \n"})}),"\n",(0,i.jsx)(n.h2,{id:"generated-code-reference",children:"Generated-code reference"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://grpc.io/docs/languages/go/generated-code/",children:"https://grpc.io/docs/languages/go/generated-code/"})}),"\n",(0,i.jsxs)(n.p,{children:["for individual streams, incoming and outgoing data is ",(0,i.jsx)(n.strong,{children:"bi-directional but serial"})]}),"\n",(0,i.jsx)(n.h3,{id:"methods-on-generated-server-interfaces",children:"Methods on generated server interfaces"}),"\n",(0,i.jsxs)(n.p,{children:["On the server side, each ",(0,i.jsx)(n.code,{children:"service Bar"})," in the ",(0,i.jsx)(n.code,{children:".proto"})," file results in the function"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"func RegisterBarServer(s *grpc.Server, srv BarServer)"})}),"\n",(0,i.jsx)(n.h4,{id:"server-streaming-methods",children:"Server-streaming methods"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Foo(*MsgA, <ServiceName>_FooServer) error"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"<ServiceName>_FooServer"})," has an embedded ",(0,i.jsx)(n.code,{children:"grpc.ServerStream"})," and the following interface"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type <ServiceName>_FooServer interface {\n\tSend(*MsgB) error\n\tgrpc.ServerStream\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"End-of-stream for the server-to-client stream is caused by the return of the handler method"}),"\n",(0,i.jsx)(n.h4,{id:"client-streaming-methods",children:"Client-streaming methods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type <ServiceName>_FooServer interface {\n\tSendAndClose(*MsgA) error\n\tRecv() (*MsgB, error)\n\tgrpc.ServerStream\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Recv"})," returns ",(0,i.jsx)(n.code,{children:"(nil, io.EOF)"})," once it has reached the end of the stream"]}),"\n",(0,i.jsxs)(n.p,{children:["The single response message from the server is sent by calling the ",(0,i.jsx)(n.code,{children:"SendAndClose"})," method on this ",(0,i.jsx)(n.code,{children:"<ServiceName>_FooServer"})," parameter. Note that ",(0,i.jsx)(n.code,{children:"SendAndClose"})," must be called once and only once"]}),"\n",(0,i.jsx)(n.h4,{id:"bidi-streaming-methods",children:"Bidi-streaming methods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type <ServiceName>_FooServer interface {\n\tSend(*MsgA) error\n\tRecv() (*MsgB, error)\n\tgrpc.ServerStream\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"methods-on-generated-client-interfaces",children:"Methods on generated client interfaces"}),"\n",(0,i.jsxs)(n.p,{children:["For client side usage, each ",(0,i.jsx)(n.code,{children:"service Bar"})," in the .proto file also results in the function: ",(0,i.jsx)(n.code,{children:"func BarClient(cc *grpc.ClientConn) BarClient"}),", which returns a concrete implementation of the ",(0,i.jsx)(n.code,{children:"BarClient"})," interface"]}),"\n",(0,i.jsx)(n.h4,{id:"unary-methods",children:"Unary Methods"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"(ctx context.Context, in *MsgA, opts ...grpc.CallOption) (*MsgB, error)"})}),"\n",(0,i.jsx)(n.h2,{id:"guides",children:"Guides"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://grpc.io/docs/guides/",children:"https://grpc.io/docs/guides/"})}),"\n",(0,i.jsx)(n.h3,{id:"cancellation",children:"Cancellation"}),"\n",(0,i.jsx)(n.p,{children:"Deadline expiration and I/O errors also trigger cancellation"}),"\n",(0,i.jsxs)(n.p,{children:["While gRPC clients do ",(0,i.jsx)(n.strong,{children:"not provide additional details"})," to the server about the reason for the cancellation, the cancel API call takes a string describing the reason, which will result in a client-side exception and/or log containing the provided reason"]}),"\n",(0,i.jsxs)(n.p,{children:["The gRPC library in general does not have a mechanism to interrupt the application-provided server handler, so the server handler must coordinate with the gRPC library to ensure that local processing of the request ceases. Therefore, if an RPC is long-lived, its server handler must ",(0,i.jsx)(n.strong,{children:"periodically check"})," if the RPC it is servicing has been cancelled and if it has, cease processing"]}),"\n",(0,i.jsx)(n.h3,{id:"deadlines",children:"Deadlines"}),"\n",(0,i.jsx)(n.h4,{id:"deadlines-on-the-client",children:"Deadlines on the Client"}),"\n",(0,i.jsxs)(n.p,{children:["If a server has gone past the deadline when processing a request, the client will give up and fail the RPC with the ",(0,i.jsx)(n.code,{children:"DEADLINE_EXCEEDED"})," status"]}),"\n",(0,i.jsx)(n.h4,{id:"deadlines-on-the-server",children:"Deadlines on the Server"}),"\n",(0,i.jsx)(n.p,{children:"A server might receive requests from a client with an unrealistically short deadline that would not give the server enough time to ever respond in time"}),"\n",(0,i.jsxs)(n.p,{children:["A gRPC server deals with this situation by automatically cancelling a call (",(0,i.jsx)(n.code,{children:"CANCELLED"})," status) once a deadline set by the client has passed"]}),"\n",(0,i.jsxs)(n.p,{children:["Since a deadline is set point in time, propagating it as-is to a server can be problematic as the clocks on the two servers might not be synchronized. To address this gRPC ",(0,i.jsx)(n.strong,{children:"converts the deadline to a timeout"})," from which the already elapsed time is already deducted."]}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://cloud.google.com/apis/design/errors#error_model",children:"https://cloud.google.com/apis/design/errors#error_model"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// The `Status` type defines a logical error model that is suitable for\n// different programming environments, including REST APIs and RPC APIs.\nmessage Status {\n  // A simple error code that can be easily handled by the client. The\n  // actual error code is defined by `google.rpc.Code`.\n  int32 code = 1;\n\n  // A developer-facing human-readable error message in English. It should\n  // both explain the error and offer an actionable resolution to it.\n  string message = 2;\n\n  // Additional error information that the client code can use to handle\n  // the error, such as retry info or a help link.\n  repeated google.protobuf.Any details = 3;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"general-errors",children:"General errors"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_CANCELLED"}),":  Client application cancelled the request"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_DEADLINE_EXCEEDED"}),": Deadline expired before server returned status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNIMPLEMENTED"}),": Method not found on server"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNAVAILABLE"}),": Server shutting down"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNKNOWN"}),": Server threw an exception (or did something other than returning a status code to terminate the RPC)"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"network-failures",children:"Network failures"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_DEADLINE_EXCEEDED"}),": No data transmitted before deadline expires. Also applies to cases where some data is transmitted and no other failures are detected before the deadline expires"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"protocol-errors",children:"Protocol errors"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_INTERNAL"}),": Could not decompress but compression algorithm supported"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNIMPLEMENTED"}),": Compression mechanism used by client not supported by the server"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_RESOURCE_EXHAUSTED"}),": Flow-control resource limits reached"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_INTERNAL"}),": Flow-control protocol violation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNKNOWN"}),": Error parsing returned status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNAUTHENTICATED"}),": Unauthenticated: credentials failed to get metadata"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_UNAUTHENTICATED"}),": Invalid host set in authority metadata"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_INTERNAL"}),": Error parsing response protocol buffer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GRPC_STATUS_INTERNAL"}),": Error parsing request protocol buffer"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"flow-control",children:"Flow Control"}),"\n",(0,i.jsxs)(n.p,{children:["It ",(0,i.jsx)(n.strong,{children:"applies to streaming RPCs and is not relevant for unary RPCs"}),". By default, gRPC handles the interactions with flow control for you, though some languages allow you to override the default behavior and take explicit control"]}),"\n",(0,i.jsx)(n.h3,{id:"health-checking",children:"Health Checking"}),"\n",(0,i.jsx)(n.p,{children:"gRPC specifies a standard service API (health/v1) for performing health check calls against gRPC servers"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/grpc/grpc-proto/blob/master/grpc/health/v1/health.proto",children:"https://github.com/grpc/grpc-proto/blob/master/grpc/health/v1/health.proto"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/grpc/grpc-go/tree/master/examples/features/health",children:"https://github.com/grpc/grpc-go/tree/master/examples/features/health"})}),"\n",(0,i.jsx)(n.h3,{id:"keepalive",children:"Keepalive"}),"\n",(0,i.jsxs)(n.p,{children:["HTTP/2 PING-based keepalives are a way to keep an HTTP/2 connection alive even when there is no data being transferred. This is done by periodically sending a ",(0,i.jsx)(n.strong,{children:"PING frame"})," to the other end of the connection"]}),"\n",(0,i.jsx)(n.h4,{id:"common-situations-where-keepalives-can-be-useful",children:"Common situations where keepalives can be useful"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When sending data over a long-lived connection which might be considered as idle by proxy or load balancers"}),"\n",(0,i.jsx)(n.li,{children:"When the network is less reliable (For example, mobile applications)"}),"\n",(0,i.jsx)(n.li,{children:"When using a connection after a long period of inactivity"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"keepalive-configuration-specification",children:"Keepalive configuration specification"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KEEPALIVE_TIME"}),": The interval in milliseconds between PING frames"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KEEPALIVE_TIMEOUT"}),": The timeout in milliseconds for a PING frame to be acknowledged. If sender does not receive an acknowledgment within this time, it will close the connection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KEEPALIVE_WITHOUT_CALLS"}),": Is it permissible to send keepalive pings from the client without any outstanding streams"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"PERMIT_KEEPALIVE_WITHOUT_CALLS"}),": Is it permissible to send keepalive pings from the client without any outstanding streams"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"PERMIT_KEEPALIVE_TIME"}),": Minimum allowed time between a server receiving successive ping frames without sending any data/header frame"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"a8-client-side-keepalive",children:"A8-client-side-keepalive"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md",children:"https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md"})}),"\n",(0,i.jsx)(n.p,{children:"To mitigate DDoS the design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Disables keepalive for HTTP/2 connections with no outstanding streams, and"}),"\n",(0,i.jsx)(n.li,{children:"Suggests for clients to avoid configuring their keepalive much below one minute (see Server Enforcement section for additional details)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Since keepalive is not occurring on HTTP/2 connections without any streams, there will be a ",(0,i.jsx)(n.strong,{children:"higher chance of failure for new RPCs following a long period of inactivity"}),". To reduce the tail latency for these RPCs, it is important to not reset the keepalive time when a connection becomes active; if a new stream is created and there has been greater than 'keepalive time' since the last read byte, then a keepalive PING should be sent (ideally before the HEADERS frame). Doing so detects the broken connection with a latency of keepalive timeout instead of keepalive time + timeout"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Restricts clients to avoid configuring their keepalive below ",(0,i.jsx)(n.strong,{children:"ten seconds"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"metadata",children:"Metadata"}),"\n",(0,i.jsxs)(n.p,{children:["gRPC metadata is a key-value pair of data that is sent with ",(0,i.jsx)(n.strong,{children:"initial or final gRPC requests or responses"}),". It is used to provide additional information about the call, such as authentication credentials, tracing information, or custom headers"]}),"\n",(0,i.jsxs)(n.p,{children:["gRPC metadata is implemented using HTTP/2 headers. The keys are ASCII strings, while the values can be either ASCII strings or binary data. The keys are case insensitive and must not start with the prefix ",(0,i.jsx)(n.code,{children:"grpc-"}),", which is reserved for gRPC itself."]}),"\n",(0,i.jsx)(n.h3,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Always ",(0,i.jsx)(n.strong,{children:"re-use stubs and channels"})," when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use keepalive pings"})," to keep HTTP/2 connections alive during periods of inactivity to allow initial RPCs to be made quickly without a dela"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use streaming RPCs"})," when handling a long-lived logical flow of data from the client-to-server, server-to-client, or in both directions. Streams can avoid continuous RPC initiation, which includes ",(0,i.jsx)(n.strong,{children:"connection load balancing at the client-side"}),", starting a ",(0,i.jsx)(n.strong,{children:"new HTTP/2 request at the transport layer"}),", and ",(0,i.jsx)(n.strong,{children:"invoking a user-defined method handler"})," on the server side"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(96540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);