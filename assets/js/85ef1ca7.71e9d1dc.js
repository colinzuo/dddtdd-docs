"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[31619],{56094:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(74848),s=t(28453);const i={},a=void 0,o={id:"programming-languages/typescript/handbook-type-manipulation",title:"handbook-type-manipulation",description:"Creating Types from Types",source:"@site/docs/00400-programming-languages/typescript/020-handbook-type-manipulation.md",sourceDirName:"00400-programming-languages/typescript",slug:"/programming-languages/typescript/handbook-type-manipulation",permalink:"/dddtdd-docs/programming-languages/typescript/handbook-type-manipulation",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:20,frontMatter:{},sidebar:"docSidebar",previous:{title:"handbook",permalink:"/dddtdd-docs/programming-languages/typescript/handbook"},next:{title:"reference",permalink:"/dddtdd-docs/programming-languages/typescript/reference"}},p={},l=[{value:"Creating Types from Types",id:"creating-types-from-types",level:2},{value:"Generics",id:"generics",level:2},{value:"Generic Constraints",id:"generic-constraints",level:3},{value:"Using Type Parameters in Generic Constraints",id:"using-type-parameters-in-generic-constraints",level:3},{value:"Using Class Types in Generics",id:"using-class-types-in-generics",level:3},{value:"Keyof Type Operator",id:"keyof-type-operator",level:2},{value:"Typeof Type Operator",id:"typeof-type-operator",level:2},{value:"Indexed Access Types",id:"indexed-access-types",level:2},{value:"Conditional Types",id:"conditional-types",level:2},{value:"Distributive Conditional Types",id:"distributive-conditional-types",level:3},{value:"Mapped Types",id:"mapped-types",level:2},{value:"Mapping Modifiers",id:"mapping-modifiers",level:3},{value:"Key Remapping via as",id:"key-remapping-via-as",level:3},{value:"Template Literal Types",id:"template-literal-types",level:2},{value:"String Unions in Types",id:"string-unions-in-types",level:3},{value:"Inference with Template Literals",id:"inference-with-template-literals",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"creating-types-from-types",children:"Creating Types from Types"}),"\n",(0,r.jsxs)(n.p,{children:["we actually have a ",(0,r.jsx)(n.strong,{children:"wide variety of type operators"})," available to use. It\u2019s also possible to ",(0,r.jsx)(n.strong,{children:"express types in terms of values"})," that we already have"]}),"\n",(0,r.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.h3,{id:"generic-constraints",children:"Generic Constraints"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface Lengthwise {\n  length: number;\n}\n \nfunction loggingIdentity<Type extends Lengthwise>(arg: Type): Type {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-type-parameters-in-generic-constraints",children:"Using Type Parameters in Generic Constraints"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key];\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-class-types-in-generics",children:"Using Class Types in Generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"keyof-type-operator",children:"Keyof Type Operator"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"keyof"})," operator takes an object type and produces a string or numeric literal union of its keys."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Point = { x: number; y: number };\ntype P = keyof Point;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If the type has a ",(0,r.jsx)(n.strong,{children:"string or number index signature"}),", ",(0,r.jsx)(n.code,{children:"keyof"})," will return those types instead"]}),"\n",(0,r.jsxs)(n.p,{children:["JavaScript object keys are ",(0,r.jsx)(n.strong,{children:"always coerced to a string"}),", so ",(0,r.jsx)(n.code,{children:"obj[0]"})," is always the same as ",(0,r.jsx)(n.code,{children:'obj["0"]'})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n    \ntype A = number\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\n    \ntype M = string | number\n"})}),"\n",(0,r.jsx)(n.h2,{id:"typeof-type-operator",children:"Typeof Type Operator"}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript adds a typeof operator you can use in a ",(0,r.jsx)(n.strong,{children:"type context"})," to refer to the type of a variable or property"]}),"\n",(0,r.jsxs)(n.p,{children:["Remember that values and types aren\u2019t the same thing. To refer to the type that the value f has, we use ",(0,r.jsx)(n.code,{children:"typeof"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>;\n    \ntype P = {\n    x: number;\n    y: number;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"indexed-access-types",children:"Indexed Access Types"}),"\n",(0,r.jsx)(n.p,{children:"The indexing type is itself a type, so we can use unions, keyof, or other types entirely"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type Person = { age: number; name: string; alive: boolean };\n\ntype I1 = Person["age" | "name"];\n     \ntype I1 = string | number\n \ntype I2 = Person[keyof Person];\n     \ntype I2 = string | number | boolean\n \ntype AliveOrName = "alive" | "name";\ntype I3 = Person[AliveOrName];\n     \ntype I3 = string | boolean\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Another example of indexing with an arbitrary type is ",(0,r.jsx)(n.strong,{children:"using number to get the type of an array\u2019s elements"}),". We can combine this with typeof to conveniently ",(0,r.jsx)(n.strong,{children:"capture the element type of an array literal"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'const MyArray = [\n  { name: "Alice", age: 15 },\n  { name: "Bob", age: 23 },\n  { name: "Eve", age: 38 },\n];\n \ntype Person = typeof MyArray[number];\n       \ntype Person = {\n    name: string;\n    age: number;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conditional-types",children:"Conditional Types"}),"\n",(0,r.jsx)(n.p,{children:"Conditional types help describe the relation between the types of inputs and outputs"}),"\n",(0,r.jsx)(n.p,{children:"the power of conditional types comes from using them with generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;\n \ninterface Email {\n  message: string;\n}\n \ninterface Dog {\n  bark(): void;\n}\n \ntype EmailMessageContents = MessageOf<Email>;\n              \ntype EmailMessageContents = string\n \ntype DogMessageContents = MessageOf<Dog>;\n             \ntype DogMessageContents = never\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Conditional types provide us with a way to ",(0,r.jsx)(n.strong,{children:"infer from types"})," we compare against in the true branch using the ",(0,r.jsx)(n.code,{children:"infer"})," keyword"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When inferring from a type with multiple call signatures (such as the type of an overloaded function), ",(0,r.jsx)(n.strong,{children:"inferences are made from the last signature"})]}),"\n",(0,r.jsx)(n.h3,{id:"distributive-conditional-types",children:"Distributive Conditional Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>;\n           \ntype StrArrOrNumArr = string[] | number[]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Typically, distributivity is the desired behavior. To ",(0,r.jsx)(n.strong,{children:"avoid that behavior, you can surround each side of the extends keyword with square brackets"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// 'StrArrOrNumArr' is no longer a union.\ntype StrArrOrNumArr = ToArrayNonDist<string | number>;\n           \ntype StrArrOrNumArr = (string | number)[]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"mapped-types",children:"Mapped Types"}),"\n",(0,r.jsx)(n.p,{children:"Mapped types: sometimes a type needs to be based on another type"}),"\n",(0,r.jsx)(n.p,{children:"A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n\ntype FeatureFlags = {\n  darkMode: () => void;\n  newUserProfile: () => void;\n};\n \ntype FeatureOptions = OptionsFlags<FeatureFlags>;\n           \ntype FeatureOptions = {\n    darkMode: boolean;\n    newUserProfile: boolean;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mapping-modifiers",children:"Mapping Modifiers"}),"\n",(0,r.jsxs)(n.p,{children:["You can remove or add these modifiers by prefixing with ",(0,r.jsx)(n.strong,{children:"- or +"}),". If you don\u2019t add a prefix, then + is assumed"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Removes 'readonly' attributes from a type's properties\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n\n// Removes 'optional' attributes from a type's properties\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key-remapping-via-as",children:"Key Remapping via as"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Getters<Type> = {\n    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n \ntype LazyPerson = Getters<Person>;\n         \ntype LazyPerson = {\n    getName: () => string;\n    getAge: () => number;\n    getLocation: () => string;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can filter out keys by ",(0,r.jsx)(n.strong,{children:"producing never"})," via a conditional type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// Remove the \'kind\' property\ntype RemoveKindField<Type> = {\n    [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]\n};\n\ninterface Circle {\n    kind: "circle";\n    radius: number;\n}\n \ntype KindlessCircle = RemoveKindField<Circle>;\n           \ntype KindlessCircle = {\n    radius: number;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can map over arbitrary unions, not just unions of ",(0,r.jsx)(n.code,{children:"string | number | symbol"}),", but unions of any type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type EventConfig<Events extends { kind: string }> = {\n    [E in Events as E["kind"]]: (event: E) => void;\n}\n\ntype SquareEvent = { kind: "square", x: number, y: number };\ntype CircleEvent = { kind: "circle", radius: number };\n \ntype Config = EventConfig<SquareEvent | CircleEvent>\n       \ntype Config = {\n    square: (event: SquareEvent) => void;\n    circle: (event: CircleEvent) => void;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"template-literal-types",children:"Template Literal Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type EmailLocaleIDs = "welcome_email" | "email_heading";\ntype FooterLocaleIDs = "footer_title" | "footer_sendoff";\n \ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\n          \ntype AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"string-unions-in-types",children:"String Unions in Types"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"power in template literals"})," comes when defining a new string based on information inside a type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type PropEventSource<Type> = {\n    on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;\n};\n \n/// Create a \"watched object\" with an 'on' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"inference-with-template-literals",children:"Inference with Template Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type PropEventSource<Type> = {\n    on<Key extends string & keyof Type>\n        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void ): void;\n};\n \ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);