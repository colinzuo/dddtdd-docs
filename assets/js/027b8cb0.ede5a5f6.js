"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[39907],{44739:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(74848),i=t(28453);const s={},o="Rendering Mechanism",a={id:"frontend/vue3/core/extras/rendering-mechanism",title:"Rendering Mechanism",description:"Virtual DOM",source:"@site/docs/00200-frontend/vue3/010-core/018-extras/030-rendering-mechanism.md",sourceDirName:"00200-frontend/vue3/010-core/018-extras",slug:"/frontend/vue3/core/extras/rendering-mechanism",permalink:"/dddtdd-docs/frontend/vue3/core/extras/rendering-mechanism",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:30,frontMatter:{},sidebar:"docSidebar",previous:{title:"Reactivity in Depth",permalink:"/dddtdd-docs/frontend/vue3/core/extras/reactivity-in-depth"},next:{title:"Render Functions & JSX",permalink:"/dddtdd-docs/frontend/vue3/core/extras/render-function"}},d={},c=[{value:"Virtual DOM",id:"virtual-dom",level:2},{value:"Render Pipeline",id:"render-pipeline",level:2},{value:"Compiler-Informed Virtual DOM",id:"compiler-informed-virtual-dom",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"rendering-mechanism",children:"Rendering Mechanism"}),"\n",(0,r.jsx)(n.h2,{id:"virtual-dom",children:"Virtual DOM"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const vnode = {\r\n  type: 'div',\r\n  props: {\r\n    id: 'hello'\r\n  },\r\n  children: [\r\n    /* more vnodes */\r\n  ]\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This process is called ",(0,r.jsx)(n.strong,{children:"mount"})]}),"\n",(0,r.jsxs)(n.p,{children:["If we have two copies of virtual DOM trees, the renderer can also walk and compare the two trees, figuring out the differences, and apply those changes to the actual DOM. This process is called ",(0,r.jsx)(n.strong,{children:"patch"}),', also known as "diffing" or "reconciliation"']}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"main benefit"})," of virtual DOM is that it gives the developer the ability to programmatically create, inspect and compose desired UI structures ",(0,r.jsx)(n.strong,{children:"in a declarative way"}),", while leaving the direct DOM manipulation to the renderer"]}),"\n",(0,r.jsx)(n.h2,{id:"render-pipeline",children:"Render Pipeline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Compile: Vue templates are compiled into ",(0,r.jsx)(n.strong,{children:"render functions"}),": functions that return virtual DOM trees"]}),"\n",(0,r.jsxs)(n.li,{children:["Mount: The runtime renderer invokes the render functions, walks the returned virtual DOM tree, and creates actual DOM nodes based on it. This step is performed as a ",(0,r.jsx)(n.strong,{children:"reactive effect"}),", so it keeps track of all reactive dependencies that were used"]}),"\n",(0,r.jsxs)(n.li,{children:["Patch: When a dependency used during mount changes, the effect re-runs. This time, a new, updated Virtual DOM tree is created. ",(0,r.jsx)(n.strong,{children:"The runtime renderer walks the new tree, compares it with the old one"}),", and applies necessary updates to the actual DOM"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"compiler-informed-virtual-dom",children:"Compiler-Informed Virtual DOM"}),"\n",(0,r.jsxs)(n.p,{children:["In Vue, the framework controls both the compiler and the runtime. This allows us to implement many compile-time optimizations that only a tightly-coupled renderer can take advantage of. The compiler can statically analyze the template and leave hints in the generated code so that the runtime can take shortcuts whenever possible. At the same time, we still preserve the capability for the user to drop down to the render function layer for more direct control in edge cases. We call this hybrid approach ",(0,r.jsx)(n.strong,{children:"Compiler-Informed Virtual DOM"})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);