"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[8392],{47700:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var r=t(74848),s=t(28453);const o={},a="Composables",c={id:"frontend/vue3/core/reusability/composables",title:"Composables",description:'What is a "Composable"?',source:"@site/docs/00200-frontend/vue3/010-core/013-reusability/010-composables.md",sourceDirName:"00200-frontend/vue3/010-core/013-reusability",slug:"/frontend/vue3/core/reusability/composables",permalink:"/dddtdd-docs/frontend/vue3/core/reusability/composables",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:10,frontMatter:{},sidebar:"docSidebar",previous:{title:"Async Components",permalink:"/dddtdd-docs/frontend/vue3/core/components-in-depth/async"},next:{title:"Custom Directives",permalink:"/dddtdd-docs/frontend/vue3/core/reusability/custom-directives"}},i={},l=[{value:"What is a &quot;Composable&quot;?",id:"what-is-a-composable",level:2},{value:"Mouse Tracker Example",id:"mouse-tracker-example",level:2},{value:"Async State Example",id:"async-state-example",level:2},{value:"Conventions and Best Practices",id:"conventions-and-best-practices",level:2},{value:"Input Arguments",id:"input-arguments",level:3},{value:"Return Values",id:"return-values",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"composables",children:"Composables"}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-composable",children:'What is a "Composable"?'}),"\n",(0,r.jsxs)(n.p,{children:['In the context of Vue applications, a "composable" is a function that leverages Vue\'s Composition API to ',(0,r.jsx)(n.strong,{children:"encapsulate and reuse stateful logic"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"mouse-tracker-example",children:"Mouse Tracker Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// event.js\r\nimport { onMounted, onUnmounted } from 'vue'\r\n\r\nexport function useEventListener(target, event, callback) {\r\n  // if you want, you can also make this\r\n  // support selector strings as target\r\n  onMounted(() => target.addEventListener(event, callback))\r\n  onUnmounted(() => target.removeEventListener(event, callback))\r\n}\r\n\r\n// mouse.js\r\nimport { ref } from 'vue'\r\nimport { useEventListener } from './event'\r\n\r\nexport function useMouse() {\r\n  const x = ref(0)\r\n  const y = ref(0)\r\n\r\n  useEventListener(window, 'mousemove', (event) => {\r\n    x.value = event.pageX\r\n    y.value = event.pageY\r\n  })\r\n\r\n  return { x, y }\r\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<script setup>\r\nimport { useMouse } from './mouse.js'\r\n\r\nconst { x, y } = useMouse()\r\n<\/script>\r\n\r\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"async-state-example",children:"Async State Example"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"toValue()"})," is an API added in 3.3. It is designed to normalize refs or getters into values. If the argument is a ref, it returns the ref's value; if the argument is a function, it will call the function and return its return value. Otherwise, it returns the argument as-is"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// fetch.js\r\nimport { ref, watchEffect, toValue } from 'vue'\r\n\r\nexport function useFetch(url) {\r\n  const data = ref(null)\r\n  const error = ref(null)\r\n\r\n  const fetchData = () => {\r\n    // reset state before fetching..\r\n    data.value = null\r\n    error.value = null\r\n\r\n    fetch(toValue(url))\r\n      .then((res) => res.json())\r\n      .then((json) => (data.value = json))\r\n      .catch((err) => (error.value = err))\r\n  }\r\n\r\n  watchEffect(() => {\r\n    fetchData()\r\n  })\r\n\r\n  return { data, error }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conventions-and-best-practices",children:"Conventions and Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"input-arguments",children:"Input Arguments"}),"\n",(0,r.jsxs)(n.p,{children:["If your composable creates reactive effects when the input is a ref or a getter, make sure to either explicitly watch the ref / getter with ",(0,r.jsx)(n.code,{children:"watch()"}),", or call ",(0,r.jsx)(n.code,{children:"toValue()"})," inside a ",(0,r.jsx)(n.code,{children:"watchEffect()"})," so that it is properly tracked"]}),"\n",(0,r.jsx)(n.h3,{id:"return-values",children:"Return Values"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"recommended convention"})," is for composables to always return a plain, non-reactive object containing multiple refs"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// x and y are refs\r\nconst { x, y } = useMouse()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you prefer to use returned state from composables as object properties, you can wrap the returned object with ",(0,r.jsx)(n.code,{children:"reactive()"})," so that the refs are unwrapped"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const mouse = reactive(useMouse())\r\n// mouse.x is linked to original ref\r\nconsole.log(mouse.x)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(96540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);