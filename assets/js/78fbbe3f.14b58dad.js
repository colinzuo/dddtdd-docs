"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[8482],{68995:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(74848),a=i(28453);const s={},r=void 0,l={id:"programming-languages/golang/lang-spec",title:"lang-spec",description:"https://go.dev/ref/spec",source:"@site/docs/00400-programming-languages/golang/lang-spec.md",sourceDirName:"00400-programming-languages/golang",slug:"/programming-languages/golang/lang-spec",permalink:"/dddtdd-docs/programming-languages/golang/lang-spec",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"how-to-write-go-code",permalink:"/dddtdd-docs/programming-languages/golang/how-to-write-go-code"},next:{title:"popular-libs",permalink:"/dddtdd-docs/programming-languages/golang/popular-libs"}},o={},c=[{value:"Rune literals",id:"rune-literals",level:2},{value:"String literals",id:"string-literals",level:2},{value:"Constants",id:"constants",level:2},{value:"Variables",id:"variables",level:2},{value:"Types",id:"types",level:2},{value:"Numeric types",id:"numeric-types",level:3},{value:"String types",id:"string-types",level:3},{value:"Array types",id:"array-types",level:3},{value:"Slice types",id:"slice-types",level:3},{value:"Struct types",id:"struct-types",level:3},{value:"Function types",id:"function-types",level:3},{value:"Interface types",id:"interface-types",level:3},{value:"Basic interfaces",id:"basic-interfaces",level:3},{value:"Embedded interfaces",id:"embedded-interfaces",level:3},{value:"General interfaces",id:"general-interfaces",level:3},{value:"Map types",id:"map-types",level:3},{value:"Channel types",id:"channel-types",level:3},{value:"Properties of types and values",id:"properties-of-types-and-values",level:2},{value:"Underlying types",id:"underlying-types",level:3},{value:"Type identity",id:"type-identity",level:3},{value:"Assignability",id:"assignability",level:3},{value:"Blocks",id:"blocks",level:2},{value:"Constant declarations",id:"constant-declarations",level:2},{value:"Type declarations",id:"type-declarations",level:2},{value:"Alias declarations",id:"alias-declarations",level:3},{value:"Type definitions",id:"type-definitions",level:3},{value:"Type parameter declarations",id:"type-parameter-declarations",level:3},{value:"Short variable declarations",id:"short-variable-declarations",level:2},{value:"Function declarations",id:"function-declarations",level:2},{value:"Method declarations",id:"method-declarations",level:2},{value:"Expressions",id:"expressions",level:2},{value:"Qualified identifiers",id:"qualified-identifiers",level:3},{value:"Composite literals",id:"composite-literals",level:3},{value:"Function literals",id:"function-literals",level:2},{value:"Selectors",id:"selectors",level:2},{value:"Method expressions",id:"method-expressions",level:2},{value:"Method values",id:"method-values",level:2},{value:"Index expressions",id:"index-expressions",level:2},{value:"Full slice expressions",id:"full-slice-expressions",level:2},{value:"Calls",id:"calls",level:2},{value:"Passing arguments to ... parameters",id:"passing-arguments-to--parameters",level:2},{value:"Instantiations",id:"instantiations",level:2},{value:"Integer operators",id:"integer-operators",level:2},{value:"Floating-point operators",id:"floating-point-operators",level:2},{value:"Comparison operators",id:"comparison-operators",level:2},{value:"Receive operator",id:"receive-operator",level:2},{value:"Conversions",id:"conversions",level:2},{value:"Conversions between numeric types",id:"conversions-between-numeric-types",level:3},{value:"Conversions to and from a string type",id:"conversions-to-and-from-a-string-type",level:3},{value:"Conversions from slice to array or array pointer",id:"conversions-from-slice-to-array-or-array-pointer",level:3},{value:"Statements",id:"statements",level:2},{value:"Send statements",id:"send-statements",level:3},{value:"Switch statements",id:"switch-statements",level:3},{value:"Expression switches",id:"expression-switches",level:4},{value:"Type switches",id:"type-switches",level:4},{value:"For statements",id:"for-statements",level:3},{value:"For statements with for clause",id:"for-statements-with-for-clause",level:4},{value:"For statements with range clause",id:"for-statements-with-range-clause",level:4},{value:"Packages",id:"packages",level:2},{value:"Import declarations",id:"import-declarations",level:3},{value:"Program initialization and execution",id:"program-initialization-and-execution",level:2},{value:"Package initialization",id:"package-initialization",level:3},{value:"Program initialization",id:"program-initialization",level:3},{value:"Program execution",id:"program-execution",level:3},{value:"Run-time panics",id:"run-time-panics",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://go.dev/ref/spec",children:"https://go.dev/ref/spec"})}),"\n",(0,t.jsx)(n.h2,{id:"rune-literals",children:"Rune literals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'rune_lit         = "\'" ( unicode_value | byte_value ) "\'" .\nunicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .\nbyte_value       = octal_byte_value | hex_byte_value .\noctal_byte_value = `\\` octal_digit octal_digit octal_digit .\nhex_byte_value   = `\\` "x" hex_digit hex_digit .\nlittle_u_value   = `\\` "u" hex_digit hex_digit hex_digit hex_digit .\nbig_u_value      = `\\` "U" hex_digit hex_digit hex_digit hex_digit\n                           hex_digit hex_digit hex_digit hex_digit .\nescaped_char     = `\\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\\` | "\'" | `"` ) .\n'})}),"\n",(0,t.jsx)(n.h2,{id:"string-literals",children:"String literals"}),"\n",(0,t.jsxs)(n.p,{children:["The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, ",(0,t.jsx)(n.strong,{children:"backslashes have no special meaning and the string may contain newlines"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'string_lit             = raw_string_lit | interpreted_string_lit .\nraw_string_lit         = "`" { unicode_char | newline } "`" .\ninterpreted_string_lit = `"` { unicode_value | byte_value } `"` .\n'})}),"\n",(0,t.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,t.jsx)(n.p,{children:"Numeric constants represent exact values of arbitrary precision and do not overflow"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"untyped constant has a default type"})," which is the type to which the constant is implicitly converted in contexts where a typed value is required"]}),"\n",(0,t.jsxs)(n.p,{children:["The default type of an untyped constant is ",(0,t.jsx)(n.strong,{children:"bool, rune, int, float64, complex128, or string"})," respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant"]}),"\n",(0,t.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"static type"})," (or just type) of a variable is the type given in its declaration, the type provided in the new call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct ",(0,t.jsx)(n.strong,{children:"dynamic type"}),", which is the (non-interface) type of the value assigned to the variable at run time"]}),"\n",(0,t.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,t.jsxs)(n.p,{children:["A type may also be specified using a ",(0,t.jsx)(n.strong,{children:"type literal"}),", which composes a type from existing types"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'Type      = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .\nTypeName  = identifier | QualifiedIdent .\nTypeArgs  = "[" TypeList [ "," ] "]" .\nTypeList  = Type { "," Type } .\nTypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |\n            SliceType | MapType | ChannelType .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"numeric-types",children:"Numeric types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"byte        alias for uint8\nrune        alias for int32\n\nuint     either 32 or 64 bits\nint      same size as uint\nuintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value\n"})}),"\n",(0,t.jsx)(n.h3,{id:"string-types",children:"String types"}),"\n",(0,t.jsxs)(n.p,{children:["Strings are ",(0,t.jsx)(n.strong,{children:"immutable"}),": once created, it is impossible to change the contents of a string"]}),"\n",(0,t.jsx)(n.h3,{id:"array-types",children:"Array types"}),"\n",(0,t.jsxs)(n.p,{children:["An array is a numbered sequence of elements of a single type, called the ",(0,t.jsx)(n.strong,{children:"element type"})]}),"\n",(0,t.jsx)(n.h3,{id:"slice-types",children:"Slice types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"make([]T, length, capacity)\n\nmake([]int, 50, 100)\nnew([100]int)[0:50]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"struct-types",children:"Struct types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'StructType    = "struct" "{" { FieldDecl ";" } "}" .\nFieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .\nEmbeddedField = [ "*" ] TypeName [ TypeArgs ] .\nTag           = string_lit .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"function-types",children:"Function types"}),"\n",(0,t.jsx)(n.p,{children:"Within a list of parameters or results, the names (IdentifierList) must either all be present or all be absent"}),"\n",(0,t.jsx)(n.p,{children:"Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type"}),"\n",(0,t.jsx)(n.p,{children:"The final incoming parameter in a function signature may have a type prefixed with .... A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter"}),"\n",(0,t.jsx)(n.h3,{id:"interface-types",children:"Interface types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'InterfaceType  = "interface" "{" { InterfaceElem ";" } "}" .\nInterfaceElem  = MethodElem | TypeElem .\nMethodElem     = MethodName Signature .\nMethodName     = identifier .\nTypeElem       = TypeTerm { "|" TypeTerm } .\nTypeTerm       = Type | UnderlyingType .\nUnderlyingType = "~" Type .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"basic-interfaces",children:"Basic interfaces"}),"\n",(0,t.jsx)(n.p,{children:"Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces"}),"\n",(0,t.jsx)(n.h3,{id:"embedded-interfaces",children:"Embedded interfaces"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type ReadWriter interface {\n\tReader  // includes methods of Reader in ReadWriter's method set\n\tWriter  // includes methods of Writer in ReadWriter's method set\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"general-interfaces",children:"General interfaces"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The type set of the empty interface is the set of all non-interface types."}),"\n",(0,t.jsx)(n.li,{children:"The type set of a non-empty interface is the intersection of the type sets of its interface elements."}),"\n",(0,t.jsx)(n.li,{children:"The type set of a method specification is the set of all non-interface types whose method sets include that method."}),"\n",(0,t.jsx)(n.li,{children:"The type set of a non-interface type term is the set consisting of just that type."}),"\n",(0,t.jsx)(n.li,{children:"The type set of a term of the form ~T is the set of all types whose underlying type is T."}),"\n",(0,t.jsx)(n.li,{children:"The type set of a union of terms t1|t2|\u2026|tn is the union of the type sets of the terms."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Interfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"var x Float                     // illegal: Float is not a basic interface\n\nvar x interface{} = Float(nil)  // illegal\n\ntype Floatish struct {\n\tf Float                 // illegal\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"map-types",children:"Map types"}),"\n",(0,t.jsxs)(n.p,{children:["A map is an ",(0,t.jsx)(n.strong,{children:"unordered"})," group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type"]}),"\n",(0,t.jsx)(n.p,{children:"A nil map is equivalent to an empty map except that no elements may be added"}),"\n",(0,t.jsx)(n.h3,{id:"channel-types",children:"Channel types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"<-"})," operator specifies the channel direction, send or receive. If a direction is given, the channel is ",(0,t.jsx)(n.strong,{children:"directional"}),", otherwise it is ",(0,t.jsx)(n.strong,{children:"bidirectional"})]}),"\n",(0,t.jsx)(n.p,{children:"A nil channel is never ready for communication"}),"\n",(0,t.jsx)(n.h2,{id:"properties-of-types-and-values",children:"Properties of types and values"}),"\n",(0,t.jsx)(n.h3,{id:"underlying-types",children:"Underlying types"}),"\n",(0,t.jsx)(n.p,{children:"Each type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T's underlying type is the underlying type of the type to which T refers in its declaration"}),"\n",(0,t.jsx)(n.h3,{id:"type-identity",children:"Type identity"}),"\n",(0,t.jsx)(n.p,{children:"A named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent"}),"\n",(0,t.jsx)(n.h3,{id:"assignability",children:"Assignability"}),"\n",(0,t.jsx)(n.p,{children:'A value x of type V is assignable to a variable of type T ("x is assignable to T") if one of the following conditions applies:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"V and T are identical."}),"\n",(0,t.jsx)(n.li,{children:"V and T have identical underlying types but are not type parameters and at least one of V or T is not a named type."}),"\n",(0,t.jsx)(n.li,{children:"V and T are channel types with identical element types, V is a bidirectional channel, and at least one of V or T is not a named type."}),"\n",(0,t.jsx)(n.li,{children:"T is an interface type, but not a type parameter, and x implements T."}),"\n",(0,t.jsx)(n.li,{children:"x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type, but not a type parameter."}),"\n",(0,t.jsx)(n.li,{children:"x is an untyped constant representable by a value of type T"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"blocks",children:"Blocks"}),"\n",(0,t.jsx)(n.p,{children:"In addition to explicit blocks in the source code, there are implicit blocks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The universe block encompasses all Go source text."}),"\n",(0,t.jsx)(n.li,{children:"Each package has a package block containing all Go source text for that package."}),"\n",(0,t.jsx)(n.li,{children:"Each file has a file block containing all Go source text in that file."}),"\n",(0,t.jsx)(n.li,{children:'Each "if", "for", and "switch" statement is considered to be in its own implicit block.'}),"\n",(0,t.jsx)(n.li,{children:'Each clause in a "switch" or "select" statement acts as an implicit block'}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"constant-declarations",children:"Constant declarations"}),"\n",(0,t.jsx)(n.p,{children:"Within a parenthesized const declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list"}),"\n",(0,t.jsx)(n.h2,{id:"type-declarations",children:"Type declarations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .\nTypeSpec = AliasDecl | TypeDef .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"alias-declarations",children:"Alias declarations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'AliasDecl = identifier "=" Type .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"type-definitions",children:"Type definitions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"TypeDef = identifier [ TypeParameters ] Type .\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The new type is called a ",(0,t.jsx)(n.strong,{children:"defined type"}),". It is different from any other type, including the type it is created from"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type (\n\tPoint struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types\n\tpolar Point                   // polar and Point denote different types\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A defined type may have methods associated with it. It ",(0,t.jsx)(n.strong,{children:"does not inherit any methods bound to the given type"}),", but the method set of an interface type or of elements of a composite type remains unchanged"]}),"\n",(0,t.jsx)(n.h3,{id:"type-parameter-declarations",children:"Type parameter declarations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'TypeParameters  = "[" TypeParamList [ "," ] "]" .\nTypeParamList   = TypeParamDecl { "," TypeParamDecl } .\nTypeParamDecl   = IdentifierList TypeConstraint .\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The predeclared interface type ",(0,t.jsx)(n.strong,{children:"comparable"})," denotes the set of all non-interface types that are strictly comparable"]}),"\n",(0,t.jsx)(n.h2,{id:"short-variable-declarations",children:"Short variable declarations"}),"\n",(0,t.jsxs)(n.p,{children:["Unlike regular variable declarations, a short variable declaration may ",(0,t.jsx)(n.strong,{children:"redeclare"})," variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and ",(0,t.jsx)(n.strong,{children:"at least one of the non-blank variables is new"})]}),"\n",(0,t.jsx)(n.p,{children:"Short variable declarations may appear only inside functions"}),"\n",(0,t.jsx)(n.h2,{id:"function-declarations",children:"Function declarations"}),"\n",(0,t.jsxs)(n.p,{children:["A function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented ",(0,t.jsx)(n.strong,{children:"outside Go"}),", such as an assembly routine"]}),"\n",(0,t.jsx)(n.h2,{id:"method-declarations",children:"Method declarations"}),"\n",(0,t.jsxs)(n.p,{children:["A receiver base type cannot be a pointer or interface type and it ",(0,t.jsx)(n.strong,{children:"must be defined in the same package as the method"}),". The method is said to be bound to its receiver base type and the method name is visible only within selectors for type T or *T."]}),"\n",(0,t.jsx)(n.h2,{id:"expressions",children:"Expressions"}),"\n",(0,t.jsxs)(n.p,{children:["An expression specifies the computation of a value by applying ",(0,t.jsx)(n.strong,{children:"operators and functions"})," to ",(0,t.jsx)(n.strong,{children:"operands"})]}),"\n",(0,t.jsx)(n.h3,{id:"qualified-identifiers",children:"Qualified identifiers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'QualifiedIdent = PackageName "." identifier .\n'})}),"\n",(0,t.jsx)(n.h3,{id:"composite-literals",children:"Composite literals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'CompositeLit  = LiteralType LiteralValue .\nLiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |\n                SliceType | MapType | TypeName [ TypeArgs ] .\nLiteralValue  = "{" [ ElementList [ "," ] ] "}" .\nElementList   = KeyedElement { "," KeyedElement } .\nKeyedElement  = [ Key ":" ] Element .\nKey           = FieldName | Expression | LiteralValue .\nFieldName     = identifier .\nElement       = Expression | LiteralValue .\n'})}),"\n",(0,t.jsx)(n.p,{children:"Note that the zero value for a slice or map type is not the same as an initialized but empty value of the same type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0\np2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The notation ",(0,t.jsx)(n.code,{children:"..."})," specifies an array length equal to the maximum element index plus one"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'buffer := [10]string{}             // len(buffer) == 10\nintSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6\ndays := [...]string{"Sat", "Sun"}  // len(days) == 2\n'})}),"\n",(0,t.jsx)(n.p,{children:"A slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one"}),"\n",(0,t.jsx)(n.p,{children:"shorthand for a slice operation applied to an array"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"tmp := [n]T{x1, x2, \u2026 xn}\ntmp[0 : n]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Within a composite literal of array, slice, or map type T, elements or map keys that are themselves composite literals may ",(0,t.jsx)(n.strong,{children:"elide the respective literal type"})," if it is identical to the element or key type of ",(0,t.jsx)(n.code,{children:"T"}),". Similarly, elements or keys that are addresses of composite literals may elide the ",(0,t.jsx)(n.code,{children:"&T"})," when the element or key type is ",(0,t.jsx)(n.code,{children:"*T"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}\n[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}\n[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}\nmap[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}\nmap[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}\n\ntype PPoint *Point\n[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}\n[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"function-literals",children:"Function literals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'FunctionLit = "func" Signature FunctionBody .\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Function literals are ",(0,t.jsx)(n.strong,{children:"closures"}),": they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible"]}),"\n",(0,t.jsx)(n.h2,{id:"selectors",children:"Selectors"}),"\n",(0,t.jsx)(n.p,{children:"For a primary expression x that is not a package name, the selector expression"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"x.f\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The identifier ",(0,t.jsx)(n.code,{children:"f"})," is called the (field or method) ",(0,t.jsx)(n.strong,{children:"selector"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["As an exception, if the type of x is a ",(0,t.jsx)(n.strong,{children:"defined pointer type"})," and ",(0,t.jsx)(n.code,{children:"(*x).f"})," is a valid selector expression denoting a field (but ",(0,t.jsx)(n.strong,{children:"not a method"}),"), x.f is shorthand for (*x).f"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"method-expressions",children:"Method expressions"}),"\n",(0,t.jsxs)(n.p,{children:["If M is in the method set of type T, ",(0,t.jsx)(n.code,{children:"T.M"})," is a function that is callable as a regular function with the same arguments as M prefixed by an additional argument that is the receiver of the method"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'MethodExpr    = ReceiverType "." MethodName .\nReceiverType  = Type .\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type T struct {\n\ta int\n}\nfunc (tv  T) Mv(a int) int         { return 0 }  // value receiver\nfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"T.Mv"}),": ",(0,t.jsx)(n.code,{children:"func(tv T, a int) int"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"(*T).Mp"}),": ",(0,t.jsx)(n.code,{children:"func(tp *T, f float32) float32"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"(*T).Mv"}),": ",(0,t.jsx)(n.code,{children:"func(tv *T, a int) int"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"method-values",children:"Method values"}),"\n",(0,t.jsxs)(n.p,{children:["If the expression x has static type T and M is in the method set of type T, ",(0,t.jsx)(n.code,{children:"x.M"})," is called a ",(0,t.jsx)(n.strong,{children:"method value"})]}),"\n",(0,t.jsx)(n.p,{children:"The expression x is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls"}),"\n",(0,t.jsx)(n.h2,{id:"index-expressions",children:"Index expressions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"a[x]\n"})}),"\n",(0,t.jsx)(n.p,{children:"For a of map type M:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["if the map is ",(0,t.jsx)(n.code,{children:"nil"})," or does not contain such an entry, ",(0,t.jsx)(n.code,{children:"a[x]"})," is the zero value for the element type of M"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"full-slice-expressions",children:"Full slice expressions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"a[low : high : max]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The indices are in range if ",(0,t.jsx)(n.code,{children:"0 <= low <= high <= max <= cap(a)"}),", otherwise they are out of range"]}),"\n",(0,t.jsx)(n.h2,{id:"calls",children:"Calls"}),"\n",(0,t.jsxs)(n.p,{children:["As a special case, if the return values of a function or method ",(0,t.jsx)(n.code,{children:"g"})," are equal in number and individually assignable to the parameters of another function or method ",(0,t.jsx)(n.code,{children:"f"}),", then the call ",(0,t.jsx)(n.code,{children:"f(g(parameters_of_g))"})," will invoke f after binding the return values of g to the parameters of f in order. The call of f must contain no parameters other than the call of g, and g must have at least one return value"]}),"\n",(0,t.jsx)(n.h2,{id:"passing-arguments-to--parameters",children:"Passing arguments to ... parameters"}),"\n",(0,t.jsxs)(n.p,{children:["If f is variadic with a final parameter p of type ",(0,t.jsx)(n.code,{children:"...T"}),", then within f the type of p is equivalent to type ",(0,t.jsx)(n.code,{children:"[]T"}),"\nIf f is invoked with no actual arguments for p, the value passed to p is ",(0,t.jsx)(n.code,{children:"nil"})]}),"\n",(0,t.jsxs)(n.p,{children:["If the final argument is assignable to a slice type ",(0,t.jsx)(n.code,{children:"[]T"})," and is followed by ",(0,t.jsx)(n.code,{children:"..."}),", it is passed unchanged as the value for a ",(0,t.jsx)(n.code,{children:"...T"})," parameter"]}),"\n",(0,t.jsx)(n.h2,{id:"instantiations",children:"Instantiations"}),"\n",(0,t.jsxs)(n.p,{children:["When using a generic function, type arguments may be provided explicitly, or they ",(0,t.jsx)(n.strong,{children:"may be partially or completely inferred"})," from the context in which the function is used"]}),"\n",(0,t.jsx)(n.h2,{id:"integer-operators",children:"Integer operators"}),"\n",(0,t.jsx)(n.p,{children:"If the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs"}),"\n",(0,t.jsx)(n.h2,{id:"floating-point-operators",children:"Floating-point operators"}),"\n",(0,t.jsx)(n.p,{children:"The result of a floating-point or complex division by zero is not specified beyond the IEEE-754 standard; whether a run-time panic occurs is implementation-specific"}),"\n",(0,t.jsx)(n.h2,{id:"comparison-operators",children:"Comparison operators"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"String types are comparable and ordered. Two string values are compared lexically byte-wise"}),"\n",(0,t.jsx)(n.li,{children:"Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value nil"}),"\n",(0,t.jsx)(n.li,{children:"Interface types that are not type parameters are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil"}),"\n",(0,t.jsx)(n.li,{children:"A value x of non-interface type X and a value t of interface type T can be compared if type X is comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x"}),"\n",(0,t.jsx)(n.li,{children:"Struct types are comparable if all their field types are comparable"}),"\n",(0,t.jsx)(n.li,{children:"Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Slice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier nil"}),"\n",(0,t.jsx)(n.h2,{id:"receive-operator",children:"Receive operator"}),"\n",(0,t.jsx)(n.p,{children:"Receiving from a nil channel blocks forever"}),"\n",(0,t.jsx)(n.p,{children:"A receive operation on a closed channel can always proceed immediately, yielding the element type's zero value after any previously sent values have been received"}),"\n",(0,t.jsx)(n.h2,{id:"conversions",children:"Conversions"}),"\n",(0,t.jsx)(n.p,{children:"Struct tags are ignored when comparing struct types for identity for the purpose of conversion"}),"\n",(0,t.jsx)(n.p,{children:"Specific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of x and incur a run-time cost. All other conversions only change the type but not the representation of x"}),"\n",(0,t.jsx)(n.h3,{id:"conversions-between-numeric-types",children:"Conversions between numeric types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"conversions-to-and-from-a-string-type",children:"Conversions to and from a string type"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings"}),"\n",(0,t.jsx)(n.li,{children:"Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string"}),"\n",(0,t.jsx)(n.li,{children:'Finally, for historical reasons, an integer value may be converted to a string type. This form of conversion yields a string containing the (possibly multi-byte) UTF-8 representation of the Unicode code point with the given integer value. Values outside the range of valid Unicode code points are converted to "\\uFFFD"'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"conversions-from-slice-to-array-or-array-pointer",children:"Conversions from slice to array or array pointer"}),"\n",(0,t.jsx)(n.p,{children:"Converting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the length of the slice is less than the length of the array, a run-time panic occurs"}),"\n",(0,t.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"Statement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n"})}),"\n",(0,t.jsx)(n.h3,{id:"send-statements",children:"Send statements"}),"\n",(0,t.jsxs)(n.p,{children:["A send on a closed channel proceeds by causing a run-time panic. A send on a ",(0,t.jsx)(n.code,{children:"nil"})," channel blocks forever"]}),"\n",(0,t.jsx)(n.h3,{id:"switch-statements",children:"Switch statements"}),"\n",(0,t.jsx)(n.h4,{id:"expression-switches",children:"Expression switches"}),"\n",(0,t.jsxs)(n.p,{children:["A missing switch expression is equivalent to the boolean value ",(0,t.jsx)(n.code,{children:"true"})]}),"\n",(0,t.jsxs)(n.p,{children:['In a case or default clause, the last non-empty statement may be a (possibly labeled) "',(0,t.jsx)(n.code,{children:"fallthrough"}),'" statement to indicate that control should flow from the end of this clause to the first statement of the next clause']}),"\n",(0,t.jsx)(n.h4,{id:"type-switches",children:"Type switches"}),"\n",(0,t.jsxs)(n.p,{children:["It is marked by a special switch expression that has the form of a type assertion using the keyword ",(0,t.jsx)(n.code,{children:"type"})," rather than an actual type"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"switch x.(type) {\n// cases\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Instead of a type, a case may use the predeclared identifier nil; that case is selected when the expression in the TypeSwitchGuard is a nil interface value"}),"\n",(0,t.jsx)(n.p,{children:'The "fallthrough" statement is not permitted in a type switch.'}),"\n",(0,t.jsx)(n.h3,{id:"for-statements",children:"For statements"}),"\n",(0,t.jsx)(n.h4,{id:"for-statements-with-for-clause",children:"For statements with for clause"}),"\n",(0,t.jsx)(n.p,{children:"Each iteration has its own separate declared variable (or variables) [Go 1.22]. The variable used by the first iteration is declared by the init statement. The variable used by each subsequent iteration is declared implicitly before executing the post statement and initialized to the value of the previous iteration's variable at that moment"}),"\n",(0,t.jsx)(n.h4,{id:"for-statements-with-range-clause",children:"For statements with range clause"}),"\n",(0,t.jsxs)(n.p,{children:["The range expression x is ",(0,t.jsx)(n.strong,{children:"evaluated once before beginning the loop"})]}),"\n",(0,t.jsxs)(n.p,{children:["The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is ",(0,t.jsx)(n.strong,{children:"removed during iteration"}),", the corresponding iteration value will not be produced. If ",(0,t.jsx)(n.strong,{children:"a map entry is created"})," during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next"]}),"\n",(0,t.jsxs)(n.p,{children:['The iteration variables may be declared by the "range" clause using a form of short variable declaration (:=). In this case their scope is the block of the "for" statement and each iteration has its ',(0,t.jsx)(n.strong,{children:"own new variables"})," [Go 1.22]"]}),"\n",(0,t.jsx)(n.h2,{id:"packages",children:"Packages"}),"\n",(0,t.jsx)(n.h3,{id:"import-declarations",children:"Import declarations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .\nImportSpec       = [ "." | PackageName ] ImportPath .\nImportPath       = string_lit .\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the ",(0,t.jsx)(n.strong,{children:"PackageName is omitted"}),", it defaults to the identifier specified in the package clause of the imported package. If an ",(0,t.jsx)(n.strong,{children:"explicit period (.)"})," appears instead of a name, all the package's exported identifiers declared in that package's package block will be declared in the importing source file's file block and must be accessed without a qualifier"]}),"\n",(0,t.jsx)(n.h2,{id:"program-initialization-and-execution",children:"Program initialization and execution"}),"\n",(0,t.jsx)(n.h3,{id:"package-initialization",children:"Package initialization"}),"\n",(0,t.jsx)(n.p,{children:"Within a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables"}),"\n",(0,t.jsxs)(n.p,{children:["The declaration order of variables declared in multiple files is determined by the ",(0,t.jsx)(n.strong,{children:"order in which the files are presented to the compiler"}),": Variables declared in the first file are declared before any of the variables declared in the second file, and so on. To ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler"]}),"\n",(0,t.jsxs)(n.p,{children:["Variables may also be initialized using functions named ",(0,t.jsx)(n.code,{children:"init"})," declared in the package block, with no arguments and no result parameters"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func init() { \u2026 }\n"})}),"\n",(0,t.jsx)(n.p,{children:"Multiple such functions may be defined per package, even within a single source file"}),"\n",(0,t.jsx)(n.p,{children:"The entire package is initialized by assigning initial values to all its package-level variables followed by calling all init functions in the order they appear in the source, possibly in multiple files, as presented to the compiler"}),"\n",(0,t.jsx)(n.h3,{id:"program-initialization",children:"Program initialization"}),"\n",(0,t.jsx)(n.p,{children:"The packages of a complete program are initialized stepwise, one package at a time. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once"}),"\n",(0,t.jsxs)(n.p,{children:["Package initialization\u2014variable initialization and the ",(0,t.jsx)(n.strong,{children:"invocation of init functions\u2014happens in a single goroutine"}),", sequentially, one package at a time. An init function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the init functions: it will not invoke the next one until the previous one has returned"]}),"\n",(0,t.jsx)(n.h3,{id:"program-execution",children:"Program execution"}),"\n",(0,t.jsxs)(n.p,{children:["A complete program is created by linking a single, unimported package called the ",(0,t.jsx)(n.code,{children:"main"})," package with all the packages it imports, transitively. The main package must have package name ",(0,t.jsx)(n.code,{children:"main"})," and declare a function ",(0,t.jsx)(n.code,{children:"main"})," that takes no arguments and returns no value"]}),"\n",(0,t.jsxs)(n.p,{children:["Program execution begins by initializing the program and then invoking the function main in package main. When that function invocation returns, the program exits. It ",(0,t.jsx)(n.strong,{children:"does not wait for other (non-main) goroutines to complete"})]}),"\n",(0,t.jsx)(n.h2,{id:"run-time-panics",children:"Run-time panics"}),"\n",(0,t.jsxs)(n.p,{children:["Execution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function panic with a value of the implementation-defined interface type ",(0,t.jsx)(n.code,{children:"runtime.Error"})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);