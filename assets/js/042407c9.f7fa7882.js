"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[24262],{36785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>s,toc:()=>l});var o=n(74848),i=n(28453);const c={title:"Allocating Objects on the Heap"},r=void 0,s={id:"programming-languages/python/c-api/allocation",title:"Allocating Objects on the Heap",description:"- PyObject _PyObject_New(PyTypeObject type)",source:"@site/docs/00400-programming-languages/python/c-api/1160-allocation.md",sourceDirName:"00400-programming-languages/python/c-api",slug:"/programming-languages/python/c-api/allocation",permalink:"/dddtdd-docs/programming-languages/python/c-api/allocation",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:1160,frontMatter:{title:"Allocating Objects on the Heap"},sidebar:"docSidebar",previous:{title:"Object Implementation Support",permalink:"/dddtdd-docs/programming-languages/python/c-api/objimpl"},next:{title:"Common Object Structures",permalink:"/dddtdd-docs/programming-languages/python/c-api/structures"}},a={},l=[];function d(e){const t={code:"code",li:"li",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyObject *_PyObject_New(PyTypeObject *type)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyVarObject *_PyObject_NewVar(PyTypeObject *type, Py_ssize_t size)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyObject *PyObject_Init(PyObject *op, PyTypeObject *type)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyVarObject *PyObject_InitVar(PyVarObject *op, PyTypeObject *type, Py_ssize_t size)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyObject_New(TYPE, typeobj)"})}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"PyObject_NewVar(TYPE, typeobj, size)"}),": The allocated memory allows for the TYPE structure plus size (Py_ssize_t) fields of the size given by the tp_itemsize field of typeobj. This is useful for implementing objects like tuples, which are able to determine their size at construction time. Embedding the array of fields into the same allocation decreases the number of allocations, improving the memory management efficiency"]}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"void PyObject_Del(void *op)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"PyObject _Py_NoneStruct"})}),"\n"]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var o=n(96540);const i={},c=o.createContext(i);function r(e){const t=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(c.Provider,{value:t},e.children)}}}]);