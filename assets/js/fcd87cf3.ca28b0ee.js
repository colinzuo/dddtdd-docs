"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[8541],{55028:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>c,toc:()=>a});var t=r(74848),o=r(28453);const l={},s=void 0,c={id:"programming-languages/python/libs/pytest/collect",title:"collect",description:"main.py _main",source:"@site/docs/00400-programming-languages/python/libs/pytest/120-collect.md",sourceDirName:"00400-programming-languages/python/libs/pytest",slug:"/programming-languages/python/libs/pytest/collect",permalink:"/dddtdd-docs/programming-languages/python/libs/pytest/collect",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1733377229e3,sidebarPosition:120,frontMatter:{},sidebar:"docSidebar",previous:{title:"startup",permalink:"/dddtdd-docs/programming-languages/python/libs/pytest/startup"},next:{title:"runtestloop",permalink:"/dddtdd-docs/programming-languages/python/libs/pytest/runtestloop"}},i={},a=[{value:"main.py _main",id:"mainpy-_main",level:2},{value:"main.py pytest_collection",id:"mainpy-pytest_collection",level:2},{value:"main.py Session.perform_collect",id:"mainpy-sessionperform_collect",level:2},{value:"runner.py collect_one_node",id:"runnerpy-collect_one_node",level:2},{value:"runner.py pytest_make_collect_report",id:"runnerpy-pytest_make_collect_report",level:2},{value:"main.py Session.collect",id:"mainpy-sessioncollect",level:2},{value:"main.py Session.genitems",id:"mainpy-sessiongenitems",level:2},{value:"main.py Session._collect_path",id:"mainpy-session_collect_path",level:2},{value:"main.py pytest_collect_directory",id:"mainpy-pytest_collect_directory",level:2},{value:"main.py Dir.collect",id:"mainpy-dircollect",level:3},{value:"python.py pytest_collect_directory",id:"pythonpy-pytest_collect_directory",level:2},{value:"python.py Package.collect",id:"pythonpy-packagecollect",level:3},{value:"python.py pytest_collect_file",id:"pythonpy-pytest_collect_file",level:2},{value:"python.py pytest_pycollect_makemodule",id:"pythonpy-pytest_pycollect_makemodule",level:2},{value:"python.py Module",id:"pythonpy-module",level:2},{value:"python.py PyCollector collect",id:"pythonpy-pycollector-collect",level:2},{value:"python.py pytest_pycollect_makeitem",id:"pythonpy-pytest_pycollect_makeitem",level:2},{value:"python.py Class",id:"pythonpy-class",level:2},{value:"python.py PyCollector._genfunctions",id:"pythonpy-pycollector_genfunctions",level:2},{value:"python.py pytest_generate_tests",id:"pythonpy-pytest_generate_tests",level:2},{value:"python.py Function",id:"pythonpy-function",level:2}];function p(e){const n={code:"code",h2:"h2",h3:"h3",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"mainpy-_main",children:"main.py _main"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def _main(config: Config, session: Session) -> int | ExitCode | None:\r\n\r\n    config.hook.pytest_collection(session=session)\r\n    config.hook.pytest_runtestloop(session=session)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-pytest_collection",children:"main.py pytest_collection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def pytest_collection(session: Session) -> None:\r\n    session.perform_collect()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-sessionperform_collect",children:"main.py Session.perform_collect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"    def perform_collect(\r\n        self, args: Sequence[str] | None = None, genitems: bool = True\r\n    ) -> Sequence[nodes.Item | nodes.Collector]:\r\n\r\n            args = self.config.args\r\n\r\n            for arg in args:\r\n                collection_argument = resolve_collection_argument(\r\n                    self.config.invocation_params.dir,\r\n                    arg,\r\n                    as_pypath=self.config.option.pyargs,\r\n                )\r\n\r\n            rep = collect_one_node(self)\r\n\r\n                if rep.passed:\r\n                    for node in rep.result:\r\n                        self.items.extend(self.genitems(node))\r\n\r\n            self.config.pluginmanager.check_pending()\r\n            hook.pytest_collection_modifyitems(\r\n                session=self, config=self.config, items=items\r\n            )\r\n\r\n            hook.pytest_collection_finish(session=self)                                                                                \n"})}),"\n",(0,t.jsx)(n.h2,{id:"runnerpy-collect_one_node",children:"runner.py collect_one_node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def collect_one_node(collector: Collector) -> CollectReport:\r\n\r\n    ihook.pytest_collectstart(collector=collector)\r\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"runnerpy-pytest_make_collect_report",children:"runner.py pytest_make_collect_report"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'def pytest_make_collect_report(collector: Collector) -> CollectReport:\r\n\r\n    def collect() -> list[Item | Collector]:\r\n        # Before collecting, if this is a Directory, load the conftests.\r\n        # If a conftest import fails to load, it is considered a collection\r\n        # error of the Directory collector. This is why it\'s done inside of the\r\n        # CallInfo wrapper.\r\n        #\r\n        # Note: initial conftests are loaded early, not here.\r\n        if isinstance(collector, Directory):\r\n            collector.config.pluginmanager._loadconftestmodules(\r\n                collector.path,\r\n                collector.config.getoption("importmode"),\r\n                rootpath=collector.config.rootpath,\r\n                consider_namespace_packages=collector.config.getini(\r\n                    "consider_namespace_packages"\r\n                ),\r\n            )\r\n\r\n        return list(collector.collect())\r\n\r\n    call = CallInfo.from_call(\r\n        collect, "collect", reraise=(KeyboardInterrupt, SystemExit)\r\n    )\r\n    longrepr: None | tuple[str, int, str] | str | TerminalRepr = None\r\n    if not call.excinfo:\r\n        outcome: Literal["passed", "skipped", "failed"] = "passed"\r\n\r\n    result = call.result if not call.excinfo else None\r\n    rep = CollectReport(collector.nodeid, outcome, longrepr, result)\r\n    rep.call = call  # type: ignore # see collect_one_node\r\n    return rep        \n'})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-sessioncollect",children:"main.py Session.collect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"    def collect(self) -> Iterator[nodes.Item | nodes.Collector]:\r\n\r\n        for collection_argument in self._initial_parts:\r\n\r\n            paths = [argpath]\r\n\r\n                for path in argpath.parents:\r\n                    if not pm._is_in_confcutdir(path):\r\n                        break\r\n                    paths.insert(0, path)\r\n\r\n            work: list[tuple[nodes.Collector | nodes.Item, list[Path | str]]] = [\r\n                (self, [*paths, *names])\r\n            ]\r\n            while work:\r\n                matchnode, matchparts = work.pop()\r\n\r\n                # Pop'd all of the parts, this is a match.\r\n                if not matchparts:\r\n                    yield matchnode\r\n                    any_matched_in_initial_part = True\r\n                    continue\r\n\r\n                # Collect this level of matching.\r\n                # Collecting Session (self) is done directly to avoid endless\r\n                # recursion to this function.\r\n                subnodes: Sequence[nodes.Collector | nodes.Item]\r\n                if isinstance(matchnode, Session):\r\n                    assert isinstance(matchparts[0], Path)\r\n                    subnodes = matchnode._collect_path(matchparts[0], path_cache)\r\n                else:\r\n\r\n                    rep, duplicate = self._collect_one_node(matchnode, handle_dupes)\r\n\r\n                    subnodes = rep.result\r\n\r\n                for node in reversed(subnodes):\r\n\r\n                        work.append((node, matchparts[1:]))                                                                                                                                                                        \n"})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-sessiongenitems",children:"main.py Session.genitems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"    def genitems(self, node: nodes.Item | nodes.Collector) -> Iterator[nodes.Item]:\r\n\r\n        if isinstance(node, nodes.Item):\r\n            node.ihook.pytest_itemcollected(item=node)\r\n            yield node\r\n        else:\r\n\r\n            rep, duplicate = self._collect_one_node(node, handle_dupes)\r\n\r\n            if rep.passed:\r\n                for subnode in rep.result:\r\n                    yield from self.genitems(subnode)                        \n"})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-session_collect_path",children:"main.py Session._collect_path"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"    def _collect_path(\r\n        self,\r\n        path: Path,\r\n        path_cache: dict[Path, Sequence[nodes.Collector]],\r\n    ) -> Sequence[nodes.Collector]:\r\n\r\n        if path.is_dir():\r\n            ihook = self.gethookproxy(path.parent)\r\n            col: nodes.Collector | None = ihook.pytest_collect_directory(\r\n                path=path, parent=self\r\n            )\r\n            cols: Sequence[nodes.Collector] = (col,) if col is not None else ()\r\n\r\n        elif path.is_file():\r\n            ihook = self.gethookproxy(path)\r\n            cols = ihook.pytest_collect_file(file_path=path, parent=self)    \n"})}),"\n",(0,t.jsx)(n.h2,{id:"mainpy-pytest_collect_directory",children:"main.py pytest_collect_directory"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def pytest_collect_directory(\r\n    path: Path, parent: nodes.Collector\r\n) -> nodes.Collector | None:\r\n    return Dir.from_parent(parent, path=path)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mainpy-dircollect",children:"main.py Dir.collect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\r\n        config = self.config\r\n        col: nodes.Collector | None\r\n        cols: Sequence[nodes.Collector]\r\n        ihook = self.ihook\r\n        for direntry in scandir(self.path):\r\n            if direntry.is_dir():\r\n                path = Path(direntry.path)\r\n                if not self.session.isinitpath(path, with_parents=True):\r\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\r\n                        continue\r\n                col = ihook.pytest_collect_directory(path=path, parent=self)\r\n                if col is not None:\r\n                    yield col\r\n\r\n            elif direntry.is_file():\r\n                path = Path(direntry.path)\r\n                if not self.session.isinitpath(path):\r\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\r\n                        continue\r\n                cols = ihook.pytest_collect_file(file_path=path, parent=self)\r\n                yield from cols\n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pytest_collect_directory",children:"python.py pytest_collect_directory"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'def pytest_collect_directory(\r\n    path: Path, parent: nodes.Collector\r\n) -> nodes.Collector | None:\r\n    pkginit = path / "__init__.py"\r\n    try:\r\n        has_pkginit = pkginit.is_file()\r\n    except PermissionError:\r\n        # See https://github.com/pytest-dev/pytest/issues/12120#issuecomment-2106349096.\r\n        return None\r\n    if has_pkginit:\r\n        return Package.from_parent(parent, path=path)\r\n    return None\n'})}),"\n",(0,t.jsx)(n.h3,{id:"pythonpy-packagecollect",children:"python.py Package.collect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\r\n        # Always collect __init__.py first.\r\n        def sort_key(entry: os.DirEntry[str]) -> object:\r\n            return (entry.name != "__init__.py", entry.name)\r\n\r\n        # \u5176\u5b83\u548cDir\u76f8\u540c\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pytest_collect_file",children:"python.py pytest_collect_file"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'def pytest_collect_file(file_path: Path, parent: nodes.Collector) -> Module | None:\r\n\r\n        if not parent.session.isinitpath(file_path):\r\n            if not path_matches_patterns(\r\n                file_path, parent.config.getini("python_files")\r\n            ):\r\n                return None\r\n        ihook = parent.session.gethookproxy(file_path)\r\n        module: Module = ihook.pytest_pycollect_makemodule(\r\n            module_path=file_path, parent=parent\r\n        )    \n'})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pytest_pycollect_makemodule",children:"python.py pytest_pycollect_makemodule"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def pytest_pycollect_makemodule(module_path: Path, parent) -> Module:\r\n    return Module.from_parent(parent, path=module_path)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-module",children:"python.py Module"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Module(nodes.File, PyCollector):\r\n\r\n    def _getobj(self):\r\n        return importtestmodule(self.path, self.config)\r\n\r\n    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\r\n        self._register_setup_module_fixture()\r\n        self._register_setup_function_fixture()\r\n        self.session._fixturemanager.parsefactories(self)\r\n        return super().collect()    \n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pycollector-collect",children:"python.py PyCollector collect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'class PyCollector(PyobjMixin, nodes.Collector, abc.ABC):\r\n\r\n    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\r\n\r\n        dicts = [getattr(self.obj, "__dict__", {})]\r\n\r\n        for dic in dicts:\r\n\r\n            for name, obj in list(dic.items()):\r\n\r\n                res = ihook.pytest_pycollect_makeitem(\r\n                    collector=self, name=name, obj=obj\r\n                )\r\n\r\n                if res is None:\r\n                    continue\r\n                elif isinstance(res, list):\r\n                    values.extend(res)\r\n                else:\r\n                    values.append(res)                                                                \n'})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pytest_pycollect_makeitem",children:"python.py pytest_pycollect_makeitem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"@hookimpl(trylast=True)\r\ndef pytest_pycollect_makeitem(\r\n    collector: Module | Class, name: str, obj: object\r\n) -> None | nodes.Item | nodes.Collector | list[nodes.Item | nodes.Collector]:\r\n\r\n    if safe_isclass(obj):\r\n        if collector.istestclass(obj, name):\r\n            return Class.from_parent(collector, name=name, obj=obj)\r\n    elif collector.istestfunction(obj, name):\r\n\r\n                return list(collector._genfunctions(name, obj))                    \n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-class",children:"python.py Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Class(PyCollector):\r\n\r\n    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\r\n\r\n        # \u53d1\u73b0\u5e76\u6ce8\u518cfixture\r\n        self.session._fixturemanager.parsefactories(self.newinstance(), self.nodeid)\r\n\r\n        # \u9012\u5f52\u6536\u96c6\r\n        return super().collect()            \n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pycollector_genfunctions",children:"python.py PyCollector._genfunctions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'    def _genfunctions(self, name: str, funcobj) -> Iterator[Function]:\r\n        modulecol = self.getparent(Module)\r\n        assert modulecol is not None\r\n        module = modulecol.obj\r\n        clscol = self.getparent(Class)\r\n        cls = clscol and clscol.obj or None\r\n\r\n        # \u4ecefuncobj\u63d0\u53d6fixture\u4fe1\u606f\r\n        definition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)\r\n        fixtureinfo = definition._fixtureinfo\r\n\r\n        # \u5982\u4e0b\u6240\u8bc9\uff0cMetafunc\u4f1a\u751f\u6210\u5177\u4f53\u7684param\u7ec4\u5408\r\n        # pytest_generate_tests impls call metafunc.parametrize() which fills\r\n        # metafunc._calls, the outcome of the hook.\r\n        metafunc = Metafunc(\r\n            definition=definition,\r\n            fixtureinfo=fixtureinfo,\r\n            config=self.config,\r\n            cls=cls,\r\n            module=module,\r\n            _ispytest=True,\r\n        )\r\n\r\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\r\n\r\n        if not metafunc._calls:\r\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\r\n        else:\r\n\r\n            for callspec in metafunc._calls:\r\n                subname = f"{name}[{callspec.id}]"\r\n                yield Function.from_parent(\r\n                    self,\r\n                    name=subname,\r\n                    callspec=callspec,\r\n                    fixtureinfo=fixtureinfo,\r\n                    keywords={callspec.id: True},\r\n                    originalname=name,\r\n                )                            \n'})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-pytest_generate_tests",children:"python.py pytest_generate_tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'def pytest_generate_tests(metafunc: Metafunc) -> None:\r\n    for marker in metafunc.definition.iter_markers(name="parametrize"):\r\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Metafunc:\r\n\r\n    def parametrize(\r\n        self,\r\n        argnames: str | Sequence[str],\r\n        argvalues: Iterable[ParameterSet | Sequence[object] | object],\r\n        indirect: bool | Sequence[str] = False,\r\n        ids: Iterable[object | None] | Callable[[Any], object | None] | None = None,\r\n        scope: _ScopeName | None = None,\r\n        *,\r\n        _param_mark: Mark | None = None,\r\n    ) -> None:\r\n\r\n        argnames, parametersets = ParameterSet._for_parametrize(\r\n            argnames,\r\n            argvalues,\r\n            self.function,\r\n            self.config,\r\n            nodeid=self.definition.nodeid,\r\n        )\r\n\r\n        ids = self._resolve_parameter_set_ids(\r\n            argnames, ids, parametersets, nodeid=self.definition.nodeid\r\n        )\r\n\r\n        newcalls = []\r\n        for callspec in self._calls or [CallSpec2()]:\r\n            for param_index, (param_id, param_set) in enumerate(\r\n                zip(ids, parametersets)\r\n            ):\r\n                newcallspec = callspec.setmulti(\r\n                    argnames=argnames,\r\n                    valset=param_set.values,\r\n                    id=param_id,\r\n                    marks=param_set.marks,\r\n                    scope=scope_,\r\n                    param_index=param_index,\r\n                )\r\n                newcalls.append(newcallspec)\r\n        self._calls = newcalls                \n"})}),"\n",(0,t.jsx)(n.h2,{id:"pythonpy-function",children:"python.py Function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class Function(PyobjMixin, nodes.Item):\r\n\r\n    def __init__(\r\n        self,\r\n        name: str,\r\n        parent,\r\n        config: Config | None = None,\r\n        callspec: CallSpec2 | None = None,\r\n        callobj=NOTSET,\r\n        keywords: Mapping[str, Any] | None = None,\r\n        session: Session | None = None,\r\n        fixtureinfo: FuncFixtureInfo | None = None,\r\n        originalname: str | None = None,\r\n    ) -> None:\r\n\r\n        self.originalname = originalname or name\r\n\r\n        self.own_markers.extend(get_unpacked_marks(self.obj))\r\n        if callspec:\r\n            self.callspec = callspec\r\n            self.own_markers.extend(callspec.marks)\r\n\r\n        self.keywords.update((mark.name, mark) for mark in self.own_markers)\r\n        self.keywords.update(self.obj.__dict__)\r\n        if keywords:\r\n            self.keywords.update(keywords)\r\n\r\n        self._fixtureinfo: FuncFixtureInfo = fixtureinfo\r\n        self.fixturenames = fixtureinfo.names_closure\r\n        self._initrequest()                                    \n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(96540);const o={},l=t.createContext(o);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);