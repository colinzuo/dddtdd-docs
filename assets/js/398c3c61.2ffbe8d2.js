"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[1641],{33206:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=n(74848),s=n(28453);const i={},o=void 0,a={id:"programming-languages/golang/prometheus/doc",title:"doc",description:"https://pkg.go.dev/github.com/prometheus/clientgolang/prometheus",source:"@site/docs/00400-programming-languages/golang/prometheus/0100-doc.md",sourceDirName:"00400-programming-languages/golang/prometheus",slug:"/programming-languages/golang/prometheus/doc",permalink:"/dddtdd-docs/programming-languages/golang/prometheus/doc",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:100,frontMatter:{},sidebar:"docSidebar",previous:{title:"project-setup",permalink:"/dddtdd-docs/programming-languages/golang/project-setup"},next:{title:"testing",permalink:"/dddtdd-docs/programming-languages/golang/std-libs/testing"}},l={},c=[{value:"Variables",id:"variables",level:2},{value:"Functions",id:"functions",level:2},{value:"Collector",id:"collector",level:2},{value:"Counter",id:"counter",level:2},{value:"CounterFunc",id:"counterfunc",level:2},{value:"CounterVec",id:"countervec",level:2},{value:"CounterVecOpts",id:"countervecopts",level:2},{value:"Desc",id:"desc",level:2},{value:"Gatherer",id:"gatherer",level:2},{value:"Gauge",id:"gauge",level:2},{value:"GaugeFunc",id:"gaugefunc",level:2},{value:"Histogram",id:"histogram",level:2},{value:"HistogramOpts",id:"histogramopts",level:2},{value:"Labels",id:"labels",level:2},{value:"Metric",id:"metric",level:2},{value:"MetricVec",id:"metricvec",level:2},{value:"MultiError",id:"multierror",level:2},{value:"Observer",id:"observer",level:2},{value:"Opts",id:"opts",level:2},{value:"Registerer",id:"registerer",level:2},{value:"Registry",id:"registry",level:2},{value:"Timer",id:"timer",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://pkg.go.dev/github.com/prometheus/client_golang/prometheus",children:"https://pkg.go.dev/github.com/prometheus/client_golang/prometheus"})}),"\n",(0,r.jsxs)(t.p,{children:["Package prometheus is the core instrumentation package. It provides ",(0,r.jsx)(t.strong,{children:"metrics primitives"})," to instrument code for monitoring. It also offers a ",(0,r.jsx)(t.strong,{children:"registry"})," for metrics. Sub-packages allow to ",(0,r.jsx)(t.strong,{children:"expose the registered metrics via HTTP"})," (package promhttp) or ",(0,r.jsx)(t.strong,{children:"push them to a Pushgateway"})," (package push). There is also a sub-package promauto, which provides metrics constructors with ",(0,r.jsx)(t.strong,{children:"automatic registration"})]}),"\n",(0,r.jsxs)(t.p,{children:["All exported functions and methods are ",(0,r.jsx)(t.strong,{children:"safe to be used concurrently"})," unless specified otherwise"]}),"\n",(0,r.jsxs)(t.p,{children:["In addition to the fundamental metric types ",(0,r.jsx)(t.code,{children:"Gauge"}),", Counter, Summary, and Histogram, a very important part of the Prometheus data model is the partitioning of samples along dimensions called labels, ",(0,r.jsx)(t.strong,{children:"which results in metric vectors"}),". The fundamental types are ",(0,r.jsx)(t.code,{children:"GaugeVec"}),", CounterVec, SummaryVec, and HistogramVec."]}),"\n",(0,r.jsxs)(t.p,{children:["While only the fundamental metric types implement the ",(0,r.jsx)(t.code,{children:"Metric interface"}),", both the metrics and their vector versions implement the ",(0,r.jsx)(t.code,{children:"Collector interface"}),". A Collector manages the collection of a number of Metrics, but for convenience, a Metric can also \u201ccollect itself\u201d. Note that Gauge, Counter, Summary, and Histogram are interfaces themselves while GaugeVec, CounterVec, SummaryVec, and HistogramVec are not"]}),"\n",(0,r.jsxs)(t.p,{children:["To create instances of Metrics and their vector versions, you need a suitable \u2026Opts struct, i.e. ",(0,r.jsx)(t.code,{children:"GaugeOpts"}),", ",(0,r.jsx)(t.code,{children:"CounterOpts"}),", SummaryOpts, or HistogramOpts"]}),"\n",(0,r.jsx)(t.p,{children:"You can use multiple registries at the same time to expose different metrics in different ways. You can use separate registries for testing purposes"}),"\n",(0,r.jsx)(t.h2,{id:"variables",children:"Variables"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"var (\n\tDefaultRegisterer Registerer = defaultRegistry\n\tDefaultGatherer   Gatherer   = defaultRegistry\n)\n\nvar DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func ExponentialBuckets(start, factor float64, count int) []float64"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func ExponentialBucketsRange(min, max float64, count int) []float64"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func LinearBuckets(start, width float64, count int) []float64"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func MustRegister(cs ...Collector)"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func Register(c Collector) error"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func Unregister(c Collector) bool"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"collector",children:"Collector"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Collector interface {\n\t// Describe sends the super-set of all possible descriptors of metrics\n\t// collected by this Collector to the provided channel and returns once\n\t// the last descriptor has been sent. The sent descriptors fulfill the\n\t// consistency and uniqueness requirements described in the Desc\n\t// documentation.\n\t//\n\t// It is valid if one and the same Collector sends duplicate\n\t// descriptors. Those duplicates are simply ignored. However, two\n\t// different Collectors must not send duplicate descriptors.\n\t//\n\t// Sending no descriptor at all marks the Collector as \u201cunchecked\u201d,\n\t// i.e. no checks will be performed at registration time, and the\n\t// Collector may yield any Metric it sees fit in its Collect method.\n\t//\n\t// This method idempotently sends the same descriptors throughout the\n\t// lifetime of the Collector. It may be called concurrently and\n\t// therefore must be implemented in a concurrency safe way.\n\t//\n\t// If a Collector encounters an error while executing this method, it\n\t// must send an invalid descriptor (created with NewInvalidDesc) to\n\t// signal the error to the registry.\n\tDescribe(chan<- *Desc)\n\t// Collect is called by the Prometheus registry when collecting\n\t// metrics. The implementation sends each collected metric via the\n\t// provided channel and returns once the last metric has been sent. The\n\t// descriptor of each sent metric is one of those returned by Describe\n\t// (unless the Collector is unchecked, see above). Returned metrics that\n\t// share the same descriptor must differ in their variable label\n\t// values.\n\t//\n\t// This method may be called concurrently and must therefore be\n\t// implemented in a concurrency safe way. Blocking occurs at the expense\n\t// of total performance of rendering all registered metrics. Ideally,\n\t// Collector implementations support concurrent readers.\n\tCollect(chan<- Metric)\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"counter",children:"Counter"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Counter interface {\n\tMetric\n\tCollector\n\n\t// Inc increments the counter by 1. Use Add to increment it by arbitrary\n\t// non-negative values.\n\tInc()\n\t// Add adds the given value to the counter. It panics if the value is <\n\t// 0.\n\tAdd(float64)\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewCounter(opts CounterOpts) Counter"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"type CounterOpts Opts"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"counterfunc",children:"CounterFunc"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type CounterFunc interface {\n\tMetric\n\tCollector\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"countervec",children:"CounterVec"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type CounterVec struct {\n\t*MetricVec\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["CounterVec is a Collector that bundles a set of Counters that all share the same Desc, ",(0,r.jsx)(t.strong,{children:"but have different values for their variable labels"}),". This is used if you want to count the same thing partitioned by various dimensions (e.g. number of HTTP requests, partitioned by response code and method)"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'\thttpReqs := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: "http_requests_total",\n\t\t\tHelp: "How many HTTP requests processed, partitioned by status code and HTTP method.",\n\t\t},\n\t\t[]string{"code", "method"},\n\t)\n\tprometheus.MustRegister(httpReqs)\n\n\thttpReqs.WithLabelValues("404", "POST").Add(42)\n'})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func (v *CounterVec) WithLabelValues(lvs ...string) Counter"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"countervecopts",children:"CounterVecOpts"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type CounterVecOpts struct {\n\tCounterOpts\n\n\t// VariableLabels are used to partition the metric vector by the given set\n\t// of labels. Each label value will be constrained with the optional Contraint\n\t// function, if provided.\n\tVariableLabels ConstrainableLabels\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"desc",children:"Desc"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Desc struct {\n\t// contains filtered or unexported fields\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Desc is the descriptor used by every Prometheus Metric. It is essentially the immutable ",(0,r.jsx)(t.strong,{children:"meta-data of a Metric"})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"gatherer",children:"Gatherer"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Gatherer interface {\n\t// Gather calls the Collect method of the registered Collectors and then\n\t// gathers the collected metrics into a lexicographically sorted slice\n\t// of uniquely named MetricFamily protobufs. Gather ensures that the\n\t// returned slice is valid and self-consistent so that it can be used\n\t// for valid exposition. As an exception to the strict consistency\n\t// requirements described for metric.Desc, Gather will tolerate\n\t// different sets of label names for metrics of the same metric family.\n\t//\n\t// Even if an error occurs, Gather attempts to gather as many metrics as\n\t// possible. Hence, if a non-nil error is returned, the returned\n\t// MetricFamily slice could be nil (in case of a fatal error that\n\t// prevented any meaningful metric collection) or contain a number of\n\t// MetricFamily protobufs, some of which might be incomplete, and some\n\t// might be missing altogether. The returned error (which might be a\n\t// MultiError) explains the details. Note that this is mostly useful for\n\t// debugging purposes. If the gathered protobufs are to be used for\n\t// exposition in actual monitoring, it is almost always better to not\n\t// expose an incomplete result and instead disregard the returned\n\t// MetricFamily protobufs in case the returned error is non-nil.\n\tGather() ([]*dto.MetricFamily, error)\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"gauge",children:"Gauge"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Gauge interface {\n\tMetric\n\tCollector\n\n\t// Set sets the Gauge to an arbitrary value.\n\tSet(float64)\n\t// Inc increments the Gauge by 1. Use Add to increment it by arbitrary\n\t// values.\n\tInc()\n\t// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary\n\t// values.\n\tDec()\n\t// Add adds the given value to the Gauge. (The value can be negative,\n\t// resulting in a decrease of the Gauge.)\n\tAdd(float64)\n\t// Sub subtracts the given value from the Gauge. (The value can be\n\t// negative, resulting in an increase of the Gauge.)\n\tSub(float64)\n\n\t// SetToCurrentTime sets the Gauge to the current Unix time in seconds.\n\tSetToCurrentTime()\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewGauge(opts GaugeOpts) Gauge"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"type GaugeOpts Opts"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"gaugefunc",children:"GaugeFunc"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type GaugeFunc interface {\n\tMetric\n\tCollector\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"histogram",children:"Histogram"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Histogram interface {\n\tMetric\n\tCollector\n\n\t// Observe adds a single observation to the histogram. Observations are\n\t// usually positive or zero. Negative observations are accepted but\n\t// prevent current versions of Prometheus from properly detecting\n\t// counter resets in the sum of observations. (The experimental Native\n\t// Histograms handle negative observations properly.) See\n\t// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations\n\t// for details.\n\tObserve(float64)\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewHistogram(opts HistogramOpts) Histogram"})}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'\ttemps := prometheus.NewHistogram(prometheus.HistogramOpts{\n\t\tName:    "pond_temperature_celsius",\n\t\tHelp:    "The temperature of the frog pond.", // Sorry, we can\'t measure how badly it smells.\n\t\tBuckets: prometheus.LinearBuckets(20, 5, 5),  // 5 buckets, each 5 centigrade wide.\n\t})\n\n\t// Simulate some observations.\n\tfor i := 0; i < 1000; i++ {\n\t\ttemps.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n\t}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"histogramopts",children:"HistogramOpts"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'type HistogramOpts struct {\n\t// Namespace, Subsystem, and Name are components of the fully-qualified\n\t// name of the Histogram (created by joining these components with\n\t// "_"). Only Name is mandatory, the others merely help structuring the\n\t// name. Note that the fully-qualified name of the Histogram must be a\n\t// valid Prometheus metric name.\n\tNamespace string\n\tSubsystem string\n\tName      string\n\n\t// Help provides information about this Histogram.\n\t//\n\t// Metrics with the same fully-qualified name must have the same Help\n\t// string.\n\tHelp string\n\n\t// ConstLabels are used to attach fixed labels to this metric. Metrics\n\t// with the same fully-qualified name must have the same label names in\n\t// their ConstLabels.\n\t//\n\t// ConstLabels are only used rarely. In particular, do not use them to\n\t// attach the same labels to all your metrics. Those use cases are\n\t// better covered by target labels set by the scraping Prometheus\n\t// server, or by one specific metric (e.g. a build_info or a\n\t// machine_role metric). See also\n\t// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels\n\tConstLabels Labels\n\n\t// Buckets defines the buckets into which observations are counted. Each\n\t// element in the slice is the upper inclusive bound of a bucket. The\n\t// values must be sorted in strictly increasing order. There is no need\n\t// to add a highest bucket with +Inf bound, it will be added\n\t// implicitly. If Buckets is left as nil or set to a slice of length\n\t// zero, it is replaced by default buckets. The default buckets are\n\t// DefBuckets if no buckets for a native histogram (see below) are used,\n\t// otherwise the default is no buckets. (In other words, if you want to\n\t// use both reguler buckets and buckets for a native histogram, you have\n\t// to define the regular buckets here explicitly.)\n\tBuckets []float64\n\n\t...\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"labels",children:"Labels"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"type Labels map[string]string"})}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'myVec.With(Labels{"code": "404", "method": "GET"}).Add(42)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"metric",children:"Metric"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'type Metric interface {\n\t// Desc returns the descriptor for the Metric. This method idempotently\n\t// returns the same descriptor throughout the lifetime of the\n\t// Metric. The returned descriptor is immutable by contract. A Metric\n\t// unable to describe itself must return an invalid descriptor (created\n\t// with NewInvalidDesc).\n\tDesc() *Desc\n\t// Write encodes the Metric into a "Metric" Protocol Buffer data\n\t// transmission object.\n\t//\n\t// Metric implementations must observe concurrency safety as reads of\n\t// this metric may occur at any time, and any blocking occurs at the\n\t// expense of total performance of rendering all registered\n\t// metrics. Ideally, Metric implementations should support concurrent\n\t// readers.\n\t//\n\t// While populating dto.Metric, it is the responsibility of the\n\t// implementation to ensure validity of the Metric protobuf (like valid\n\t// UTF-8 strings or syntactically valid metric and label names). It is\n\t// recommended to sort labels lexicographically. Callers of Write should\n\t// still make sure of sorting if they depend on it.\n\tWrite(*dto.Metric) error\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"metricvec",children:"MetricVec"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type MetricVec struct {\n\t// contains filtered or unexported fields\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["MetricVec is not used directly but as a building block for implementations of vectors of a given metric type, like ",(0,r.jsx)(t.code,{children:"GaugeVec, CounterVec, SummaryVec, and HistogramVec"}),". It is exported so that it can be used for custom Metric implementations."]}),"\n",(0,r.jsx)(t.h2,{id:"multierror",children:"MultiError"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"type MultiError []error"})}),"\n",(0,r.jsx)(t.h2,{id:"observer",children:"Observer"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Observer interface {\n\tObserve(float64)\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Observer is the interface that wraps the Observe method, which is used by Histogram and Summary to add observations"}),"\n",(0,r.jsx)(t.h2,{id:"opts",children:"Opts"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'type Opts struct {\n\t// Namespace, Subsystem, and Name are components of the fully-qualified\n\t// name of the Metric (created by joining these components with\n\t// "_"). Only Name is mandatory, the others merely help structuring the\n\t// name. Note that the fully-qualified name of the metric must be a\n\t// valid Prometheus metric name.\n\tNamespace string\n\tSubsystem string\n\tName      string\n\n\t// Help provides information about this metric.\n\t//\n\t// Metrics with the same fully-qualified name must have the same Help\n\t// string.\n\tHelp string\n\n\t// ConstLabels are used to attach fixed labels to this metric. Metrics\n\t// with the same fully-qualified name must have the same label names in\n\t// their ConstLabels.\n\t//\n\t// ConstLabels are only used rarely. In particular, do not use them to\n\t// attach the same labels to all your metrics. Those use cases are\n\t// better covered by target labels set by the scraping Prometheus\n\t// server, or by one specific metric (e.g. a build_info or a\n\t// machine_role metric). See also\n\t// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels\n\tConstLabels Labels\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"It is mandatory to set Name to a non-empty string. All other fields are optional and can safely be left at their zero value, although it is strongly encouraged to set a Help string."}),"\n",(0,r.jsx)(t.h2,{id:"registerer",children:"Registerer"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Registerer interface {\n\t// Register registers a new Collector to be included in metrics\n\t// collection. It returns an error if the descriptors provided by the\n\t// Collector are invalid or if they \u2014 in combination with descriptors of\n\t// already registered Collectors \u2014 do not fulfill the consistency and\n\t// uniqueness criteria described in the documentation of metric.Desc.\n\t//\n\t// If the provided Collector is equal to a Collector already registered\n\t// (which includes the case of re-registering the same Collector), the\n\t// returned error is an instance of AlreadyRegisteredError, which\n\t// contains the previously registered Collector.\n\t//\n\t// A Collector whose Describe method does not yield any Desc is treated\n\t// as unchecked. Registration will always succeed. No check for\n\t// re-registering (see previous paragraph) is performed. Thus, the\n\t// caller is responsible for not double-registering the same unchecked\n\t// Collector, and for providing a Collector that will not cause\n\t// inconsistent metrics on collection. (This would lead to scrape\n\t// errors.)\n\tRegister(Collector) error\n\t// MustRegister works like Register but registers any number of\n\t// Collectors and panics upon the first registration that causes an\n\t// error.\n\tMustRegister(...Collector)\n\t// Unregister unregisters the Collector that equals the Collector passed\n\t// in as an argument.  (Two Collectors are considered equal if their\n\t// Describe method yields the same set of descriptors.) The function\n\t// returns whether a Collector was unregistered. Note that an unchecked\n\t// Collector cannot be unregistered (as its Describe method does not\n\t// yield any descriptor).\n\t//\n\t// Note that even after unregistering, it will not be possible to\n\t// register a new Collector that is inconsistent with the unregistered\n\t// Collector, e.g. a Collector collecting metrics with the same name but\n\t// a different help string. The rationale here is that the same registry\n\t// instance must only collect consistent metrics throughout its\n\t// lifetime.\n\tUnregister(Collector) bool\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"registry",children:"Registry"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Registry struct {\n\t// contains filtered or unexported fields\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It implements ",(0,r.jsx)(t.code,{children:"Registerer, Gatherer, and Collector"})]}),"\n",(0,r.jsx)(t.p,{children:"Registry implements Collector to allow it to be used for creating groups of metrics"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'\t// Create a global registry.\n\tglobalReg := prometheus.NewRegistry()\n\n\t// Spawn 10 workers, each of which will have their own group of metrics.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new registry for each worker, which acts as a group of\n\t\t// worker-specific metrics.\n\t\tworkerReg := prometheus.NewRegistry()\n\t\tglobalReg.Register(workerReg)\n\n\t\tgo func(workerID int) {\n\t\t\t// Once the worker is done, it can unregister itself.\n\t\t\tdefer globalReg.Unregister(workerReg)\n\n\t\t\tworkTime := prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\t\tName: "worker_total_work_time_milliseconds",\n\t\t\t\tConstLabels: prometheus.Labels{\n\t\t\t\t\t// Generate a label unique to this worker so its metric doesn\'t\n\t\t\t\t\t// collide with the metrics from other workers.\n\t\t\t\t\t"worker_id": fmt.Sprintf("%d", workerID),\n\t\t\t\t},\n\t\t\t})\n\t\t\tworkerReg.MustRegister(workTime)\n\n\t\t\tstart := time.Now()\n\t\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))\n\t\t\tworkTime.Add(float64(time.Since(start).Milliseconds()))\n\t\t}(i)\n\t}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"timer",children:"Timer"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type Timer struct {\n\t// contains filtered or unexported fields\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"func NewTimer(o Observer) *Timer"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The provided Observer is used to observe a duration in seconds"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func TimeMe() {\n    timer := NewTimer(myHistogram)\n    defer timer.ObserveDuration()\n    // Do actual work.\n}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'var apiRequestDuration = prometheus.NewHistogramVec(\n\tprometheus.HistogramOpts{\n\t\tName:    "api_request_duration_seconds",\n\t\tHelp:    "Histogram for the request duration of the public API, partitioned by status class.",\n\t\tBuckets: prometheus.ExponentialBuckets(0.1, 1.5, 5),\n\t},\n\t[]string{"status_class"},\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tstatus := http.StatusOK\n\t// The ObserverFunc gets called by the deferred ObserveDuration and\n\t// decides which Histogram\'s Observe method is called.\n\ttimer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) {\n\t\tswitch {\n\t\tcase status >= 500: // Server error.\n\t\t\tapiRequestDuration.WithLabelValues("5xx").Observe(v)\n\t\tcase status >= 400: // Client error.\n\t\t\tapiRequestDuration.WithLabelValues("4xx").Observe(v)\n\t\tcase status >= 300: // Redirection.\n\t\t\tapiRequestDuration.WithLabelValues("3xx").Observe(v)\n\t\tcase status >= 200: // Success.\n\t\t\tapiRequestDuration.WithLabelValues("2xx").Observe(v)\n\t\tdefault: // Informational.\n\t\t\tapiRequestDuration.WithLabelValues("1xx").Observe(v)\n\t\t}\n\t}))\n\tdefer timer.ObserveDuration()\n\n\t// Handle the request. Set status accordingly.\n\t// ...\n}\n'})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(96540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);