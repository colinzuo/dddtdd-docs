"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[3022],{7842:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=t(74848),r=t(28453);const i={},o=void 0,a={id:"programming-languages/python/c-api/intro",title:"intro",description:"https://docs.python.org/3.11/c-api/intro.html",source:"@site/docs/00400-programming-languages/python/c-api/0100-intro.md",sourceDirName:"00400-programming-languages/python/c-api",slug:"/programming-languages/python/c-api/intro",permalink:"/dddtdd-docs/programming-languages/python/c-api/intro",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:100,frontMatter:{},sidebar:"docSidebar",previous:{title:"intro",permalink:"/dddtdd-docs/programming-languages/python/packaging/setuptools/intro"},next:{title:"C API Stability",permalink:"/dddtdd-docs/programming-languages/python/c-api/stable"}},c={},l=[{value:"Coding standards",id:"coding-standards",level:2},{value:"Include Files",id:"include-files",level:2},{value:"Useful macros",id:"useful-macros",level:2},{value:"Objects, Types and Reference Counts",id:"objects-types-and-reference-counts",level:2},{value:"Reference Count Details",id:"reference-count-details",level:3},{value:"Exceptions",id:"exceptions",level:2},{value:"Embedding Python",id:"embedding-python",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.python.org/3.11/c-api/intro.html",children:"https://docs.python.org/3.11/c-api/intro.html"})}),"\n",(0,s.jsxs)(n.p,{children:["There are ",(0,s.jsx)(n.strong,{children:"two fundamentally different reasons"})," for using the Python/C API. The first reason is to ",(0,s.jsx)(n.strong,{children:"write extension modules"})," for specific purposes; these are C modules that extend the Python interpreter. This is probably the most common use. The second reason is to use Python as a component in a larger application; this technique is generally referred to as ",(0,s.jsx)(n.strong,{children:"embedding Python"})," in an application."]}),"\n",(0,s.jsx)(n.h2,{id:"coding-standards",children:"Coding standards"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://peps.python.org/pep-0007/",children:"https://peps.python.org/pep-0007/"})}),"\n",(0,s.jsx)(n.h2,{id:"include-files",children:"Include Files"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All user visible names defined by Python.h (except those defined by the included standard headers) have one of the prefixes ",(0,s.jsx)(n.strong,{children:"Py or _Py"}),". Names beginning with ",(0,s.jsx)(n.strong,{children:"_Py are for internal use"})," by the Python implementation and should not be used by extension writers"]}),"\n",(0,s.jsx)(n.h2,{id:"useful-macros",children:"Useful macros"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Py_UNREACHABLE()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Py_UNUSED(arg)"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"objects-types-and-reference-counts",children:"Objects, Types and Reference Counts"}),"\n",(0,s.jsx)(n.p,{children:"PyObject*. This type is a pointer to an opaque data type representing an arbitrary Python object."}),"\n",(0,s.jsx)(n.p,{children:"Almost all Python objects live on the heap"}),"\n",(0,s.jsxs)(n.p,{children:["Reference counts are always manipulated explicitly. The normal way is to use the macro ",(0,s.jsx)(n.code,{children:"Py_INCREF()"})," to increment an object\u2019s reference count by one, and ",(0,s.jsx)(n.code,{children:"Py_DECREF()"})," to decrement it by one."]}),"\n",(0,s.jsxs)(n.p,{children:["The type-specific deallocator takes care of ",(0,s.jsx)(n.strong,{children:"decrementing the reference counts for other objects contained in the object"})," if this is a compound object type, such as a list, as well as performing any additional finalization that\u2019s needed."]}),"\n",(0,s.jsxs)(n.p,{children:["An important situation where this arises is in objects that are passed as arguments to C functions in an extension module that are called from Python; ",(0,s.jsx)(n.strong,{children:"the call mechanism guarantees to hold a reference to every argument for the duration of the call"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A safe approach is to always use the generic operations (functions whose name begins with ",(0,s.jsx)(n.strong,{children:"PyObject_, PyNumber_, PySequence_ or PyMapping_"}),"). These operations ",(0,s.jsx)(n.strong,{children:"always increment"})," the reference count of the object they return. This leaves the caller with the responsibility to call Py_DECREF() when they are done with the result; this soon becomes second nature"]}),"\n",(0,s.jsx)(n.h3,{id:"reference-count-details",children:"Reference Count Details"}),"\n",(0,s.jsx)(n.p,{children:"Ownership pertains to references, never to objects (objects are not owned: they are always shared)."}),"\n",(0,s.jsx)(n.p,{children:"\u201cOwning a reference\u201d means being responsible for calling Py_DECREF on it when the reference is no longer needed."}),"\n",(0,s.jsx)(n.p,{children:"Ownership can also be transferred, meaning that the code that receives ownership of the reference then becomes responsible for eventually decref\u2019ing it by calling Py_DECREF() or Py_XDECREF() when it\u2019s no longer needed\u2014or passing on this responsibility (usually to its caller)."}),"\n",(0,s.jsx)(n.p,{children:"When a function passes ownership of a reference on to its caller, the caller is said to receive a new reference."}),"\n",(0,s.jsx)(n.p,{children:"When no ownership is transferred, the caller is said to borrow the reference. Nothing needs to be done for a borrowed reference."}),"\n",(0,s.jsxs)(n.p,{children:["Conversely, when a calling function passes in a reference to an object, there are two possibilities: the function ",(0,s.jsx)(n.strong,{children:"steals a reference to the object, or it does not"}),". Stealing a reference means that when you pass a reference to a function, that function assumes that it now owns that reference, and you are not responsible for it any longer"]}),"\n",(0,s.jsxs)(n.p,{children:["Few functions steal references; the two notable exceptions are ",(0,s.jsx)(n.code,{children:"PyList_SetItem()"})," and ",(0,s.jsx)(n.code,{children:"PyTuple_SetItem()"}),", which steal a reference to the item"]}),"\n",(0,s.jsxs)(n.p,{children:["However, in practice, you will rarely use these ways of creating and populating a tuple or list. There\u2019s a generic function, ",(0,s.jsx)(n.code,{children:"Py_BuildValue()"}),", that can create most common objects from C values, directed by a format string"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'PyObject *tuple, *list;\n\ntuple = Py_BuildValue("(iis)", 1, 2, "three");\nlist = Py_BuildValue("[iis]", 1, 2, "three");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,s.jsxs)(n.p,{children:["In general, when a function encounters an error, it ",(0,s.jsx)(n.strong,{children:"sets an exception, discards any object references that it owns, and returns an error indicator"}),". If not documented otherwise, this indicator is ",(0,s.jsx)(n.strong,{children:"either NULL or -1"}),", depending on the function\u2019s return type"]}),"\n",(0,s.jsx)(n.p,{children:"Exception state is maintained in per-thread storage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The function ",(0,s.jsx)(n.code,{children:"PyErr_Occurred()"})," can be used to check for this"]}),"\n",(0,s.jsxs)(n.li,{children:["There are a number of functions to set the exception state: ",(0,s.jsx)(n.code,{children:"PyErr_SetString()"})," is the most common"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PyErr_Clear()"})," clears the exception state"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The full exception state consists of three objects (all of which can be NULL): ",(0,s.jsx)(n.strong,{children:"the exception type, the corresponding exception value, and the traceback"}),". These have the same meanings as the Python result of sys.exc_info(); however, they are not the same: the Python objects represent the last exception being handled by a Python try \u2026 except statement, while the C level exception state only exists while an exception is being passed on between C functions until it reaches the Python bytecode interpreter\u2019s main loop, ",(0,s.jsx)(n.strong,{children:"which takes care of transferring it to sys.exc_info()"})," and friends"]}),"\n",(0,s.jsx)(n.h2,{id:"embedding-python",children:"Embedding Python"}),"\n",(0,s.jsxs)(n.p,{children:["The basic initialization function is ",(0,s.jsx)(n.code,{children:"Py_Initialize()"}),". This initializes the table of loaded modules, and creates the fundamental modules ",(0,s.jsx)(n.code,{children:"builtins, __main__, and sys"}),". It also initializes the module search path (sys.path)"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);