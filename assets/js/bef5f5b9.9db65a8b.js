"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[1907],{3188:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>l,toc:()=>i});var r=t(74848),s=t(28453);const c={},a="Watchers",l={id:"frontend/vue3/core/essentials/watchers",title:"Watchers",description:"Basic Example",source:"@site/docs/00200-frontend/vue3/010-core/011-essentials/110-watchers.md",sourceDirName:"00200-frontend/vue3/010-core/011-essentials",slug:"/frontend/vue3/core/essentials/watchers",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/watchers",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,sidebarPosition:110,frontMatter:{},sidebar:"docSidebar",previous:{title:"Lifecycle Hooks",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/lifecycle-hooks"},next:{title:"Template Refs",permalink:"/dddtdd-docs/frontend/vue3/core/essentials/template-refs"}},o={},i=[{value:"Basic Example",id:"basic-example",level:2},{value:"Watch Source Types",id:"watch-source-types",level:2},{value:"Deep Watchers",id:"deep-watchers",level:2},{value:"Eager Watchers",id:"eager-watchers",level:2},{value:"watchEffect()",id:"watcheffect",level:2},{value:"watch vs. watchEffect",id:"watch-vs-watcheffect",level:2},{value:"Callback Flush Timing",id:"callback-flush-timing",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"watchers",children:"Watchers"}),"\n",(0,r.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,r.jsxs)(n.p,{children:["there are cases where we need to ",(0,r.jsx)(n.strong,{children:'perform "side effects" in reaction to state changes'})," - for example, mutating the DOM, or changing another piece of state based on the result of an async operation"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<script setup>\r\nimport { ref, watch } from 'vue'\r\n\r\nconst question = ref('')\r\nconst answer = ref('Questions usually contain a question mark. ;-)')\r\nconst loading = ref(false)\r\n\r\n// watch works directly on a ref\r\nwatch(question, async (newQuestion, oldQuestion) => {\r\n  if (newQuestion.includes('?')) {\r\n    loading.value = true\r\n    answer.value = 'Thinking...'\r\n    try {\r\n      const res = await fetch('https://yesno.wtf/api')\r\n      answer.value = (await res.json()).answer\r\n    } catch (error) {\r\n      answer.value = 'Error! Could not reach the API. ' + error\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n})\r\n<\/script>\r\n\r\n<template>\r\n  <p>\r\n    Ask a yes/no question:\r\n    <input v-model=\"question\" :disabled=\"loading\" />\r\n  </p>\r\n  <p>{{ answer }}</p>\r\n</template>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"watch-source-types",children:"Watch Source Types"}),"\n",(0,r.jsxs)(n.p,{children:['watch\'s first argument can be different types of reactive "sources": it can be a ',(0,r.jsx)(n.code,{children:"ref"}),"(including computed refs), a ",(0,r.jsx)(n.code,{children:"reactive object"}),", a ",(0,r.jsx)(n.code,{children:"getter function"}),", or ",(0,r.jsx)(n.code,{children:"an array of multiple sources"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const x = ref(0)\r\nconst y = ref(0)\r\n\r\n// single ref\r\nwatch(x, (newX) => {\r\n  console.log(`x is ${newX}`)\r\n})\r\n\r\n// getter\r\nwatch(\r\n  () => x.value + y.value,\r\n  (sum) => {\r\n    console.log(`sum of x + y is: ${sum}`)\r\n  }\r\n)\r\n\r\n// array of multiple sources\r\nwatch([x, () => y.value], ([newX, newY]) => {\r\n  console.log(`x is ${newX} and y is ${newY}`)\r\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Do note"})," that you can't watch a property of a reactive object like this"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const obj = reactive({ count: 0 })\r\n\r\n// this won't work because we are passing a number to watch()\r\nwatch(obj.count, (count) => {\r\n  console.log(`Count is: ${count}`)\r\n})\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deep-watchers",children:"Deep Watchers"}),"\n",(0,r.jsxs)(n.p,{children:["When you call watch() directly on a reactive object, it will ",(0,r.jsx)(n.strong,{children:"implicitly create a deep watcher"})," - the callback will be triggered on all nested mutations"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const obj = reactive({ count: 0 })\r\n\r\nwatch(obj, (newValue, oldValue) => {\r\n  // fires on nested property mutations\r\n  // Note: `newValue` will be equal to `oldValue` here\r\n  // because they both point to the same object!\r\n})\r\n\r\nobj.count++\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This should be ",(0,r.jsx)(n.strong,{children:"differentiated"})," with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object"]}),"\n",(0,r.jsxs)(n.p,{children:["You can, however, force the second case into a deep watcher by explicitly using the ",(0,r.jsx)(n.code,{children:"deep"})," option"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"watch(\r\n  () => state.someObject,\r\n  (newValue, oldValue) => {\r\n    // Note: `newValue` will be equal to `oldValue` here\r\n    // *unless* state.someObject has been replaced\r\n  },\r\n  { deep: true }\r\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"eager-watchers",children:"Eager Watchers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"watch(\r\n  source,\r\n  (newValue, oldValue) => {\r\n    // executed immediately, then again when `source` changes\r\n  },\r\n  { immediate: true }\r\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"watcheffect",children:"watchEffect()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"watchEffect()"})," allows us to track the callback's reactive dependencies automatically"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"watch()"})," is lazy: the callback won't be called until the watched source has changed"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"watchEffect()"})," allows us to perform a side effect immediately while automatically tracking the effect's reactive dependencies"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"watchEffect(async () => {\r\n  const response = await fetch(url.value)\r\n  data.value = await response.json()\r\n})\n"})}),"\n",(0,r.jsx)(n.h2,{id:"watch-vs-watcheffect",children:"watch vs. watchEffect"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"watch"})," only tracks the explicitly watched source"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"watchEffect"})," automatically tracks every reactive property accessed during its synchronous execution"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"callback-flush-timing",children:"Callback Flush Timing"}),"\n",(0,r.jsxs)(n.p,{children:["By default, a watcher's callback is called ",(0,r.jsx)(n.strong,{children:"after"})," parent component updates (if any), and ",(0,r.jsx)(n.strong,{children:"before"})," the owner component's DOM updates"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(96540);const s={},c=r.createContext(s);function a(e){const n=r.useContext(c);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);