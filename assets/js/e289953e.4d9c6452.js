"use strict";(self.webpackChunkdoc_center=self.webpackChunkdoc_center||[]).push([[3465],{11879:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>s});var t=r(74848),c=r(28453);const o={},i=void 0,a={id:"programming-languages/golang/topics/concurrency",title:"concurrency",description:"pattern",source:"@site/docs/00400-programming-languages/golang/topics/concurrency.md",sourceDirName:"00400-programming-languages/golang/topics",slug:"/programming-languages/golang/topics/concurrency",permalink:"/dddtdd-docs/programming-languages/golang/topics/concurrency",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Colin Zuo",lastUpdatedAt:1720187019e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"string",permalink:"/dddtdd-docs/programming-languages/golang/string"},next:{title:"database",permalink:"/dddtdd-docs/programming-languages/golang/topics/database"}},l={},s=[{value:"pattern",id:"pattern",level:2},{value:"Refs",id:"refs",level:2},{value:"pipelines",id:"pipelines",level:2},{value:"Fan-out, fan-in",id:"fan-out-fan-in",level:3},{value:"merge",id:"merge",level:3},{value:"Explicit cancellation",id:"explicit-cancellation",level:3},{value:"Bryan Mills&#39;s talk on concurrency patterns",id:"bryan-millss-talk-on-concurrency-patterns",level:2},{value:"asynchronous api",id:"asynchronous-api",level:3},{value:"future api",id:"future-api",level:3},{value:"PRODUCER\u2013CONSUMER QUEUE: API",id:"producerconsumer-queue-api",level:3},{value:"CALLER-SIDE CONCURRENCY: SYNCHRONOUS API",id:"caller-side-concurrency-synchronous-api",level:3},{value:"VARIABLES",id:"variables",level:4},{value:"condition",id:"condition",level:3},{value:"COMMUNICATION: RESOURCE POOL",id:"communication-resource-pool",level:3},{value:"COMMUNICATION: QUEUE CANCELLATION",id:"communication-queue-cancellation",level:3},{value:"SEMAPHORE CHANNEL: LIMITING CONCURRENCY",id:"semaphore-channel-limiting-concurrency",level:3}];function u(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"pattern",children:"pattern"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Future: channel buffer 1, \u5355\u4e00\u7ed3\u679c\uff0c\u8fd9\u6837\u7ed3\u679c\u53ef\u4ee5\u4e0d\u963b\u585e\u5b58\u5230channel"}),"\n",(0,t.jsx)(e.li,{children:"Queue: channel unbuffer\uff0c\u591a\u4e2a\u6d88\u606f"}),"\n",(0,t.jsx)(e.li,{children:"\u7ed9\u7528\u6237\u5c55\u73b0\u540c\u6b65\u63a5\u53e3\uff0c\u5185\u90e8\u901a\u8fc7channel\u548cgoroutine\u5b9e\u73b0\u5e76\u53d1"}),"\n",(0,t.jsx)(e.li,{children:"\u5982\u679c\u5199\u5165\u4fa7\u4e0d\u68c0\u67e5\uff0c\u90a3\u4e48\u63a5\u6536\u4fa7\u54ea\u6015\u77e5\u9053\u7ed3\u679c\u6ca1\u7528\u4e5f\u9700\u8981\u63a5\u6536\u4ece\u800c\u4e0dblock\u5199\u5165\u4fa7"}),"\n",(0,t.jsx)(e.li,{children:"\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e2a\u5355\u4e00\u5143\u7d20\u7684channel\u6765\u5b9e\u73b0\u4e32\u884c\u8fd0\u884c"}),"\n",(0,t.jsx)(e.li,{children:"a worker pool can bound the peak resource usage of the program"}),"\n",(0,t.jsx)(e.li,{children:"\u901a\u8fc7channel buffer\u8bbe\u4e3alimit\u6765\u9650\u5236\u5e76\u53d1: Recall that we acquire this semaphore by sending a token, and we release it by discarding a token."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"refs",children:"Refs"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://go.dev/blog/pipelines",children:"https://go.dev/blog/pipelines"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=f6kdp27TYZs",children:"Google I/O 2012 - Go Concurrency Patterns"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=QDDwwePbDtw",children:"Google I/O 2013 - Advanced Go Concurrency Patterns"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=oV9rvDllKEg",children:"Concurrency is not Parallelism by Rob Pike"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=KBZlN0izeiY",children:"GopherCon 2017: Kavya Joshi - Understanding Channels"}),"\n",(0,t.jsx)(e.a,{href:"https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view",children:"Rethinking Classical Concurrency Patterns"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=5zXAHh5tJqQ",children:"GopherCon 2018: Bryan C. Mills - Rethinking Classical Concurrency Patterns"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=afSiVelXDTQ",children:"GopherCon 2018: Filippo Valsorda- Asynchronous Networking Patterns"}),"\n",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=YEKjSzIwAdA",children:"Concurrency Patterns In Go"}),"\n",(0,t.jsx)(e.a,{href:"https://blogtitle.github.io/categories/concurrency/",children:"Concurrency"})]}),"\n",(0,t.jsx)(e.h2,{id:"pipelines",children:"pipelines"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"https://go.dev/blog/pipelines",children:"https://go.dev/blog/pipelines"})}),"\n",(0,t.jsx)(e.p,{children:"Informally, a pipeline is a series of stages connected by channels, where each stage is a group of goroutines running the same function"}),"\n",(0,t.jsx)(e.h3,{id:"fan-out-fan-in",children:"Fan-out, fan-in"}),"\n",(0,t.jsxs)(e.p,{children:["Multiple functions can read from the same channel until that channel is closed; this is called ",(0,t.jsx)(e.strong,{children:"fan-out"})]}),"\n",(0,t.jsxs)(e.p,{children:["A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that\u2019s closed when all the inputs are closed. This is called ",(0,t.jsx)(e.strong,{children:"fan-in"})]}),"\n",(0,t.jsx)(e.h3,{id:"merge",children:"merge"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func merge(cs ...<-chan int) <-chan int {\n    var wg sync.WaitGroup\n    out := make(chan int)\n\n    // Start an output goroutine for each input channel in cs.  output\n    // copies values from c to out until c is closed, then calls wg.Done.\n    output := func(c <-chan int) {\n        for n := range c {\n            out <- n\n        }\n        wg.Done()\n    }\n    wg.Add(len(cs))\n    for _, c := range cs {\n        go output(c)\n    }\n\n    // Start a goroutine to close out once all the output goroutines are\n    // done.  This must start after the wg.Add call.\n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    return out\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"explicit-cancellation",children:"Explicit cancellation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func main() {\n    // Set up a done channel that's shared by the whole pipeline,\n    // and close that channel when this pipeline exits, as a signal\n    // for all the goroutines we started to exit.\n    done := make(chan struct{})\n    defer close(done)          \n\n    in := gen(done, 2, 3)\n\n    // Distribute the sq work across two goroutines that both read from in.\n    c1 := sq(done, in)\n    c2 := sq(done, in)\n\n    // Consume the first value from output.\n    out := merge(done, c1, c2)\n    fmt.Println(<-out) // 4 or 9\n\n    // done will be closed by the deferred call.      \n}\n\nfunc merge(done <-chan struct{}, cs ...<-chan int) <-chan int {\n    var wg sync.WaitGroup\n    out := make(chan int)\n\n    // Start an output goroutine for each input channel in cs.  output\n    // copies values from c to out until c or done is closed, then calls\n    // wg.Done.\n    output := func(c <-chan int) {\n        defer wg.Done()\n        for n := range c {\n            select {\n            case out <- n:\n            case <-done:\n                return\n            }\n        }\n    }\n    // ... the rest is unchanged ...\n"})}),"\n",(0,t.jsx)(e.h2,{id:"bryan-millss-talk-on-concurrency-patterns",children:"Bryan Mills's talk on concurrency patterns"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view",children:"Bryan Mills's talk on concurrency patterns"})}),"\n",(0,t.jsx)(e.h3,{id:"asynchronous-api",children:"asynchronous api"}),"\n",(0,t.jsx)(e.p,{children:"An asynchronous API returns to the caller before its result is ready."}),"\n",(0,t.jsx)(e.p,{children:"\u901a\u8fc7callback\u83b7\u53d6\u7ed3\u679c"}),"\n",(0,t.jsx)(e.h3,{id:"future-api",children:"future api"}),"\n",(0,t.jsx)(e.p,{children:"\u901a\u8fc7\u6307\u5b9a\u63a5\u53e3\u83b7\u53d6\u7ed3\u679c"}),"\n",(0,t.jsx)(e.p,{children:"golang\u91cc\u53ef\u4ee5\u901a\u8fc7\u8fd4\u56debuffer\u4e3a1\u7684channel\uff0c\u7136\u540e\u4ecechannel\u83b7\u53d6"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"c := make(chan Item, 1)"})}),"\n",(0,t.jsx)(e.h3,{id:"producerconsumer-queue-api",children:"PRODUCER\u2013CONSUMER QUEUE: API"}),"\n",(0,t.jsx)(e.p,{children:"producer\u548cconsumer\u4e4b\u95f4\u901a\u8fc7channel\u901a\u4fe1"}),"\n",(0,t.jsx)(e.h3,{id:"caller-side-concurrency-synchronous-api",children:"CALLER-SIDE CONCURRENCY: SYNCHRONOUS API"}),"\n",(0,t.jsx)(e.h4,{id:"variables",children:"VARIABLES"}),"\n",(0,t.jsx)(e.p,{children:"\u901a\u8fc7errgroup\u4f7f\u7528goroutine\u6765\u5e76\u53d1\uff0c\u7136\u540e\u5728\u91cc\u9762\u901a\u8fc7closure\u628a\u7ed3\u679c\u8bbe\u7f6e\u5230variable\u4e0a"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'var a, b Item\ng, ctx := errgroup.WithContext(ctx)\ng.Go(func() (err error) {\n    a, err = Fetch(ctx, "a")\n    return err\n})\ng.Go(func() (err error) {\n    b, err = Fetch(ctx, "b")\n    return err\n})\nerr := g.Wait()\n[...]\nconsume(a, b)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"condition",children:"condition"}),"\n",(0,t.jsx)(e.p,{children:"condition\u7684\u95ee\u9898"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u6ca1\u6cd5cancel"}),"\n",(0,t.jsx)(e.li,{children:"wakeup\u4e0d\u53ef\u63a7"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"communication-resource-pool",children:"COMMUNICATION: RESOURCE POOL"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func (p *Pool) Acquire(ctx context.Context) (net.Conn, error) {\n    select {\n    case conn := <-p.idle:\n        return conn, nil\n    case p.sem <- token{}:\n        conn, err := dial()\n        if err != nil {\n            <-p.sem\n        }\n        return conn, err\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"communication-queue-cancellation",children:"COMMUNICATION: QUEUE CANCELLATION"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func (q *Queue) Get(ctx context.Context) (Item, error) {\n    var items []Item\n\n    select {\n    case <-ctx.Done():\n        return 0, ctx.Err()\n    case items = <-q.items:\n    }\n\n    item := items[0]\n    if len(items) == 1 {\n        q.empty <- true\n    } else {\n        q.items <- items[1:]\n    }\n\n    return item, nil\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"semaphore-channel-limiting-concurrency",children:"SEMAPHORE CHANNEL: LIMITING CONCURRENCY"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"sem := make(chan token, limit)\nfor _, task := range hugeSlice {\n    sem <- token{}\n    go func(task Task) {\n        perform(task)\n        <-sem\n    }(task)\n}\n"})})]})}function d(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},28453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>a});var t=r(96540);const c={},o=t.createContext(c);function i(n){const e=t.useContext(o);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:i(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);