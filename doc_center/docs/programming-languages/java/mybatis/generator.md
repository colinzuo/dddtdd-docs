
<https://mybatis.org/generator/index.html>

## Introduction

It will introspect a database table (or many tables) and will generate artifacts that can be used to access the table(s).

MBG seeks to make a major impact on the large percentage of database operations that are simple CRUD (Create, Retrieve, Update, Delete). You will still need to hand code SQL and objects for join queries, or stored procedures.

1. MBG will automatically merge XML files if there is an existing file with the same name as the newly generated XML file. MBG will not overwrite any custom changes you make to the XML files it generates
2. MBG will not merge Java files

## What's New

The *ByExample methods are removed. They are replaced by general count/delete/select/update methods that allow a where clause to be added via a lambda

The new generated update method is far more flexible than the prior version. It can be used to mimic the old updateByExample and updateByExampleSelective methods, but it can also be used to generate update methods with any combination of update columns. So, for example, you can create an update statement that will insert nulls into some fields and ignore other fields. This has been an ongoing frustration with the prior update methods and is now resolved

## Quick Start Guide

<https://mybatis.org/generator/quickstart.html#MyBatis3DynamicSql>

## Running MyBatis Generator

Important: When running outside of an IDE environment like Eclipse, MBG interprets the targetProject and targetPackage attributes in all XML configurations as follows:

- targetProject is assumed to be an existing directory structure. MBG will fail if this directory structure does not exist. There is one exception to this rule - when MBG is running through the Maven plugin. See the Maven plugin page for information about how targetProject is interpreted in Maven.
- targetPackage will be translated to a suitable subdirectory structure of the targetProject directory structure. MBG will create these subdirectories if necessary.

<https://mybatis.org/generator/running/runningWithJava.html>

## Generator调用

`<generatedKey column="id" sqlStatement="JDBC" identity="true"/>`

在insert后会查询返回id

## XML Configuration File Reference

### commentGenerator

The default Comment Generator adds JavaDoc comments to all generated Java elements to enable the Java **merge functionality in the Eclipse plugin**

### context

targetRuntime: MyBatis3DynamicSql

The model objects are generated in the "FLAT" style regardless of what is specified for the "defaultModelType". This also means that there are no "with BLOBs" and "without BLOBs" methods.

**No XML will be generated. `<sqlMapGenerator>` is not required** and will be ignored if specified.

### generatedKey

If you specify this element, MyBatis Generator (MBG) will generate an appropriate `<selectKey>` element inside the generated `<insert>` element in the SQL map

## MyBatis Dynamic SQL Usage Notes

For each introspected table, the generator will generate three objects:

1. A "record" class that represents a row in the table. This is the same as other runtimes
2. A "support" class that includes a table definition and column definitions for the database table
3. A mapper interface with all the typical methods generated by the other runtimes.

### Format of the "Support" classes

In your code, it is typical to import the static elements of this support class so they can be used directly in the code you write. With this static import you can refer to the fields in either a direct or qualified manner - "id" or "tableCode.id".

### Usage of the Mapper Classes

The following methods work the same as the other runtimes and we won't cover them here:

- Delete by Primary Key
- Insert - will insert nulls
- insert selective - ignores null properties
- Select by Primary Key
- Update by Primary Key - will set null values
- Update by Primary Key Selective - ignores null values

There are no "by example" methods. Instead, there are general purpose methods that allow you to specify a where clause with a lambda. The generator will create the following general:

- count
- delete
- select
- selectDistinct
- selectOne
- update

It is far more interesting to add WHERE clauses to these methods. To add support for WHERE clauses, you should import the static elements from the support class as shown above, and you should also import the SqlBuilder support. Then you can code arbitrarily complex where clauses, and "ORDER BY" phrases as shown below

```java
    public void complexWhere2() {
        ...
        // complex WHERE and ORDER BY
        List<TableCode> records = mapper.select(c ->
                c.where(id, isLessThan(10), and(description, isEqualTo("foo")))
                .or(description, isLike("b%"))
                .orderBy(id.descending()));        
        ...
    }
```

### Update Method Usage

The generated update statement is very flexible. You can now create any arbitrary update, as well as updates that mimic the old updateByExample and updateByExampleSelective methods

```java
    public void simpleUpdate() {
        ...
        // Flexible update - no backing record needed
        int rows = mapper.update(c ->
                c.set(id).equalTo(1)
                .set(description).equalToNull()
                .where(id, isEqualTo(3)));
        ...
    }

    public void updateByExample(TableCode record) {
        ...
        // Update like the old updateByExample method
        int rows =  mapper.update(c ->
                TableCodeMapper.updateAllColumns(record, c)
                .where(id, isEqualTo(3))
                .or(description, isLike("f%")));
        ...
    }

    public void updateByExampleSelective(TableCode record) {
        ...
        // Update like the old updateByExampleSelective method
        int rows =  mapper.update(c ->
                TableCodeMapper.updateSelectiveColumns(record, c)
                .where(id, isEqualTo(3))
                .or(description, isLike("f%")));
        ...
    }
```

## MySql Usage Notes

### Catalogs and Schema

MySql syntax does not support the standard catalog..table SQL syntax.

For this reason, it is best to not specify either catalog or schema in generator configurations. Just specify table names and specify the database in the JDBC URL.

If you are using version 8.x of Connector/J you may notice that the generator attempts to generate code for tables in the MySql information schemas (sys, information_schema, performance_schema, etc.) This is probably not what you want! To disable this behavior, add the property "nullCatalogMeansCurrent=true" to your JDBC URL


